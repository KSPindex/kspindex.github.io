<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index-Space :: Desktop (Unified Core)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-background: #0D1117;
            --color-text-primary: #E6EDF3;
            --color-text-secondary: #8B949E;
            --color-window-bg: #161B22;
            --color-window-header: #0D1117;
            --color-window-border: #30363D;
            --color-window-border-active: #58A6FF;
            --color-taskbar-bg: rgba(22, 27, 34, 0.7);
            --color-accent-primary: #4A5588; /* Blue-purple for shapes */
            --color-accent-secondary: #303651; /* Darker blue-purple for shapes */
            --font-primary: 'Inter', 'Segoe UI', 'Helvetica Neue', 'Arial', sans-serif;
            --shadow-window: 0 20px 50px rgba(0, 0, 0, 0.4);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: var(--color-background); color: var(--color-text-primary); font-family: var(--font-primary); user-select: none; }
        #aurora-background { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; overflow: hidden; }
        .aurora-shape { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.1; animation: drift 25s infinite alternate; }
        .shape1 { width: 70vw; height: 70vw; top: -20%; left: -20%; background: var(--color-accent-primary); }
        .shape2 { width: 60vw; height: 60vw; bottom: -20%; right: -20%; background: var(--color-accent-secondary); animation-duration: 35s; }
        @keyframes drift { from { transform: translate(0, 0) rotate(0deg) scale(1); } to { transform: translate(10vw, 5vh) rotate(45deg) scale(1.2); } }
        #desktop { width: 100%; height: 100%; position: relative; }
        #taskbar { position: fixed; bottom: 0; left: 0; width: 100%; height: 55px; background: var(--color-taskbar-bg); backdrop-filter: blur(15px); border-top: 1px solid var(--color-window-border); display: flex; justify-content: center; align-items: center; padding: 0 1rem; z-index: 10000; }
        .taskbar-icons { display: flex; gap: 0.5rem; }
        .app-icon { 
            width: 42px; height: 42px; background-color: rgba(255, 255, 255, 0.05); border-radius: 8px; cursor: pointer; border: 1px solid transparent; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; position: relative; transition: all 0.2s ease; 
            overflow: visible; /* Allow dot to spill outside */
        }
        .app-icon:hover { background-color: rgba(255, 255, 255, 0.1); transform: translateY(-3px); }
        .app-icon.active::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); width: 6px; height: 6px; background-color: var(--color-window-border-active); border-radius: 50%; }
        
        /* Notification dot style */
        .notification-dot {
            position: absolute;
            top: -3px; 
            right: -3px; 
            width: 12px;
            height: 12px;
            background-color: #ff5555; /* Red color */
            border-radius: 50%;
            box-shadow: 0 0 5px 2px rgba(255, 85, 85, 0.5); /* Neon effect, slightly smaller */
            animation: pulse-glow 1.5s infinite alternate;
            z-index: 1; /* Ensure it's above the icon */
        }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 5px 2px rgba(255, 85, 85, 0.5); }
            100% { box-shadow: 0 0 10px 4px rgba(255, 85, 85, 0.8); }
        }

        .window { position: absolute; background: var(--color-window-bg); border: 1px solid var(--color-window-border); border-radius: 12px; box-shadow: var(--shadow-window); display: flex; flex-direction: column; resize: both; overflow: hidden; min-width: 400px; min-height: 300px; opacity: 0; transform: scale(0.95); animation: openWindow 0.3s forwards cubic-bezier(0.16, 1, 0.3, 1); }
        @keyframes openWindow { to { opacity: 1; transform: scale(1); } }
        .window.active { border-color: var(--color-window-border-active); }
        .window-header { width: 100%; height: 36px; background: var(--color-window-header); cursor: move; display: flex; align-items: center; justify-content: flex-start; padding: 0 10px; flex-shrink: 0; border-bottom: 1px solid var(--color-window-border); }
        .window-controls { display: flex; gap: 8px; margin-right: auto; }
        .control-btn { width: 12px; height: 12px; border-radius: 50%; border: none; cursor: pointer; }
        .close-btn { background-color: #FF5F57; }
        .minimize-btn { background-color: #FEBC2E; }
        .maximize-btn { background-color: #28C840; }
        .window-title { color: var(--color-text-secondary); font-size: 0.85rem; text-align: center; flex-grow: 1; padding-right: 70px; }
        .window-content { flex-grow: 1; overflow-y: auto; }
        .window-content.has-iframe { padding: 0; }
        .window-content.has-content { padding: 1.5rem; line-height: 1.7; }
        .window-content iframe { width: 100%; height: 100%; border: none; }
        .placeholder-content { display: flex; justify-content: center; align-items: center; height: 100%; color: var(--color-text-secondary); padding: 1.5rem; text-align: center; }
        
        /* Welcome App Specific Styles */
        .welcome-content h2 { font-size: 1.8rem; font-weight: 700; color: var(--color-window-border-active); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-window-border); }
        .welcome-content h3 { font-size: 1.2rem; font-weight: 500; color: var(--color-text-primary); margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .welcome-content p { color: var(--color-text-secondary); font-size: 1rem; margin-bottom: 1rem; }
        .welcome-content strong { color: var(--color-text-primary); font-weight: 500; }
    </style>
</head>
<body>
    <div id="aurora-background"><div class="aurora-shape shape1"></div><div class="aurora-shape shape2"></div></div>
    <div id="desktop"></div>
    <div id="taskbar"><div id="taskbar-icons" class="taskbar-icons"></div></div>
    
    <script>
    /**
     * JSDoc: @file desktop.js (Unified Version)
     * @description Index-Space ê°€ìƒ OSì˜ í•µì‹¬ ë°ìŠ¤í¬í†±. iframe ë¡œë”©ê³¼ ë„¤ì´í‹°ë¸Œ ì•±ì„ ëª¨ë‘ ì§€ì›.
     * @version 2.5 - Editor ë° Terminal ì¬êµ¬ì¶•ì— ë”°ë¥¸ ì—°ë™ ì—…ë°ì´íŠ¸
     */
    const IndexSpaceOS = {
        state: { windows: new Map(), activeWindowId: null, maxZIndex: 100 },
        config: {
            apps: [
                {   
                    id: 'welcome',  
                    name: 'Welcome to Index-Space',  
                    icon: 'ğŸš€',
                    launch: (winId) => {
                        const contentEl = document.getElementById(`content-${winId}`);
                        contentEl.classList.add('welcome-content', 'has-content');
                        contentEl.innerHTML = `
                            <h2>íƒ„ìƒ (The Genesis)</h2>
                            <p>ì›¹ì˜ ë°œì „ì€ ëˆˆë¶€ì…¨ì§€ë§Œ, ìš°ë¦¬ëŠ” ê·¸ ê³¼ì •ì—ì„œ ë¬´ì–¸ê°€ë¥¼ ìƒì–´ë²„ë ¸ìŠµë‹ˆë‹¤. ìˆ˜ë§ì€ í”„ë ˆì„ì›Œí¬ì™€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì¶”ìƒí™” ê³„ì¸µ ì•„ë˜, ì›¹ ê¸°ìˆ ì˜ ìˆœìˆ˜í•œ ë³¸ì§ˆì€ í¬ë¯¸í•´ì¡ŒìŠµë‹ˆë‹¤. ê°œë°œìëŠ” ë” ì´ìƒ DOMì„ ì§ì ‘ ì œì–´í•˜ì§€ ì•Šê³ , CSSì˜ ë™ì‘ ì›ë¦¬ë¥¼ ê¹Šì´ ê³ ë¯¼í•˜ì§€ ì•Šìœ¼ë©°, JavaScriptì˜ ë¬´í•œí•œ ê°€ëŠ¥ì„±ì„ ìŠ¤ìŠ¤ë¡œ íƒí—˜í•˜ê¸°ë³´ë‹¤ ì •í•´ì§„ í‹€ì— ìì‹ ì„ ë§ì¶”ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                            <p><strong>Index-Space</strong>ëŠ” ì´ëŸ¬í•œ í˜„ì‹¤ì— ëŒ€í•œ ì² í•™ì  ë°˜ê¸°ì´ì ê¸°ìˆ ì  ë„ì „ì…ë‹ˆë‹¤. "ë§Œì•½ í˜„ëŒ€ ì›¹ë¸Œë¼ìš°ì €ë¼ëŠ” ê°•ë ¥í•œ ê¸°ë°˜ ìœ„ì—ì„œ, ì™¸ë¶€ ì˜ì¡´ì„± ì—†ì´ ìˆœìˆ˜í•œ ë„¤ì´í‹°ë¸Œ ê¸°ìˆ ë§Œìœ¼ë¡œ í•˜ë‚˜ì˜ ì™„ì „í•œ ìš´ì˜ì²´ì œë¥¼ êµ¬ì¶•í•œë‹¤ë©´ ì–´ë–¨ê¹Œ?" ë¼ëŠ” ì§ˆë¬¸ì—ì„œ ì´ í”„ë¡œì íŠ¸ëŠ” ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ë‹¨ìˆœí•œ ì›¹ì‚¬ì´íŠ¸ê°€ ì•„ë‹Œ, ë¸Œë¼ìš°ì €ì˜ í•œê³„ë¥¼ ì‹œí—˜í•˜ê³  ì›¹ ê°œë°œì˜ ê·¼ë³¸ìœ¼ë¡œ íšŒê·€í•˜ë ¤ëŠ” í•˜ë‚˜ì˜ ì„ ì–¸ì…ë‹ˆë‹¤.</p>
                            
                            <h2>ì² í•™ (Our Philosophy)</h2>
                            <h3>1. ìˆœìˆ˜í•¨ê³¼ ì„±ëŠ¥ (Purity and Performance)</h3>
                            <p>Index-Spaceì˜ ëª¨ë“  ì½”ë“œëŠ” ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´ ì§ì ‘ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì°½ ê´€ë¦¬ ì‹œìŠ¤í…œ, ê°€ìƒ íŒŒì¼ ì‹œìŠ¤í…œ, ì• í”Œë¦¬ì¼€ì´ì…˜ ëŸ°ì²˜, ì‹¬ì§€ì–´ ì´ ì°½ì„ ì›€ì§ì´ëŠ” ë¡œì§ê¹Œì§€ ëª¨ë‘ ìˆœìˆ˜ JavaScriptë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ëŠ” ë¶ˆí•„ìš”í•œ ì½”ë“œ ì—†ì´ ìµœì ì˜ ì„±ëŠ¥ì„ ë³´ì¥í•˜ë©°, ê°œë°œìê°€ ëª¨ë“  ê²ƒì˜ ë™ì‘ ì›ë¦¬ë¥¼ ëª…í™•íˆ ì´í•´í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.</p>
                            
                            <h3>2. ì œí•œ ì—†ëŠ” ì°½ì˜ì„± (Unbounded Creativity)</h3>
                            <p>ì´ê³³ì€ ë‹¹ì‹ ì˜ ìƒŒë“œë°•ìŠ¤ì…ë‹ˆë‹¤. ì„œë²„ì˜ ì œì•½ë„, ë³µì¡í•œ ë¹Œë“œ ê³¼ì •ë„ ì—†ìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì €ê°€ í—ˆìš©í•˜ëŠ” ëª¨ë“  ê²ƒì€ Index-Space ì•ˆì—ì„œ ê°€ëŠ¥í•©ë‹ˆë‹¤. VFSì— íŒŒì¼ì„ ì €ì¥í•˜ê³ , ìì²´ ì œì‘ ì—ë””í„°ë¡œ ì½”ë“œë¥¼ ìˆ˜ì •í•˜ë©°, ì¦‰ì‹œ ì‹¤í–‰ë˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ì–´ ë³´ì„¸ìš”. ë‹¹ì‹ ì˜ ì•„ì´ë””ì–´ê°€ ìœ ì¼í•œ í•œê³„ì…ë‹ˆë‹¤.</p>

                            <h3>3. ê¹Šì´ ìˆëŠ” í•™ìŠµ (Deep Learning)</h3>
                            <p>Index-SpaceëŠ” ê²°ê³¼ë¬¼ì¸ ë™ì‹œì— ê³¼ì • ê·¸ ìì²´ì…ë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì˜ ì†ŒìŠ¤ ì½”ë“œë¥¼ ë“¤ì—¬ë‹¤ë³´ëŠ” ê²ƒì€ í˜„ëŒ€ ìš´ì˜ì²´ì œì˜ í•µì‹¬ êµ¬ì„± ìš”ì†Œë“¤ì´ ì–´ë–»ê²Œ ì›ì‹œì ì¸ ì›¹ ê¸°ìˆ ë¡œë¶€í„° íƒ„ìƒí•˜ëŠ”ì§€ë¥¼ ëª©ê²©í•˜ëŠ” ì—¬ì •ì…ë‹ˆë‹¤. ì´ëŠ” ëª¨ë“  ì›¹ ê°œë°œìì—ê²Œ ìì‹ ì˜ ê¸°ìˆ  ìŠ¤íƒì— ëŒ€í•œ ê¹Šì´ ìˆëŠ” í†µì°°ë ¥ê³¼ ìì‹ ê°ì„ ë¶€ì—¬í•  ê²ƒì…ë‹ˆë‹¤.</p>
                        `;
                    }
                },
                { id: 'fileExplorer', name: 'File Explorer', icon: 'ğŸ“', url: './FileExplorer.html' }, // Example for consistency, though editor handles file Browse
                { id: 'terminal', name: 'Terminal', icon: 'ğŸ‘¨â€ğŸ’»', url: './terminal.html' }, 
                { id: 'editor', name: 'Code Editor', icon: 'ğŸ“', url: './editor.html' },   
                { id: 'settings', name: 'Settings', icon: 'âš™ï¸', url: './Settings.html' },
                { id: 'arcade', name: 'Arcade', icon: 'ğŸ®', url: './Arcade.html' },
            ]
        },
        dom: {},
        terminalDotTimeout: null, // For managing the notification dot timeout
        
        init() {
            this.dom = { desktop: document.getElementById('desktop'), taskbarIcons: document.getElementById('taskbar-icons') };
            this.TaskbarManager.init(this);
            this.WindowManager.init(this);
            this.setupInterWindowCommunication(); // Setup message listener
            
            // Launch Welcome app on startup
            const welcomeApp = this.config.apps.find(a => a.id === 'welcome');
            if (welcomeApp) {
                this.WindowManager.launchApp(welcomeApp);
            }
        },

        // Function to handle terminal activity notification
        handleTerminalActivity() {
            const terminalAppIcon = document.querySelector('.app-icon[data-app-id="terminal"]');
            if (!terminalAppIcon) return;

            let notificationDot = terminalAppIcon.querySelector('.notification-dot');
            if (!notificationDot) {
                notificationDot = document.createElement('div');
                notificationDot.id = 'terminal-notification-dot'; // Add ID for direct access if needed
                notificationDot.className = 'notification-dot';
                terminalAppIcon.appendChild(notificationDot);
            }
            notificationDot.classList.remove('hidden'); // Show the dot
            
            // Clear any previous timeout to keep the dot visible longer
            clearTimeout(this.terminalDotTimeout);
            this.terminalDotTimeout = setTimeout(() => {
                notificationDot.classList.add('hidden');
                // Optionally remove dot from DOM if hidden to clean up
                // notificationDot.remove(); 
            }, 5000); // Hide after 5 seconds of no activity
        },

        setupInterWindowCommunication() {
            window.addEventListener('message', (event) => {
                // Ensure messages are from expected origins for security (in production)
                // if (event.origin !== window.location.origin) return; 

                const { type, payload } = event.data;

                switch (type) {
                    case 'terminalActivity':
                        // Message from editor.html indicating terminal output
                        this.handleTerminalActivity();
                        break;
                    case 'appReady':
                        // When an app (like editor.html or terminal.html) sends 'appReady'
                        const appInstance = this.config.apps.find(app => app.id === payload.appId);
                        if (appInstance) {
                            // Find the iframe associated with this app window
                            const windowEl = document.querySelector(`#${payload.windowId} iframe`);
                            if (windowEl && windowEl.contentWindow) {
                                // Store the iframe's contentWindow object directly in the app config
                                appInstance.iframeWindow = windowEl.contentWindow;
                                console.log(`Desktop: ${payload.appId} iframe ready and contentWindow stored.`);
                            }
                        }
                        break;
                    // Add other message types if needed
                }
            });
        }
    };

    /** @class Window - Represents a single application window with support for both iframe and native apps. */
    class Window {
        constructor(app, os, options = {}) {
            this.id = `win-${Date.now()}`;
            this.app = app;
            this.os = os;
            this.options = options;
            this.iframe = null; // To store iframe element if applicable
            this.create();
            this.bindEvents();
        }
        
        create() {
            this.el = document.createElement('div');
            this.el.id = this.id;
            this.el.className = 'window';
            
            // Window sizing - flexible based on content type
            if (this.app.id === 'welcome') {
                this.el.style.width = this.options.width || '720px';
                this.el.style.height = this.options.height || '500px';
            } else {
                this.el.style.width = this.options.width || '80vw';
                this.el.style.height = this.options.height || '70vh';
            }
            
            // Window positioning with smart offset
            const windowCount = this.os.state.windows.size;
            const offsetX = (windowCount % 10) * 20;
            const offsetY = (windowCount % 10) * 20;
            this.el.style.left = `calc(50% - ${parseInt(this.el.style.width) / 2}px + ${offsetX}px)`;
            this.el.style.top = `calc(50% - ${parseInt(this.el.style.height) / 2}px + ${offsetY}px)`;
            
            // Initial content setup
            let contentHTML = `<div class="placeholder-content">Loading ${this.app.name}...</div>`;
            
            this.el.innerHTML = `
                <div class="window-header">
                    <div class="window-controls">
                        <button class="control-btn close-btn" title="Close"></button>
                        <button class="control-btn minimize-btn" title="Minimize"></button>
                        <button class="control-btn maximize-btn" title="Maximize"></button>
                    </div>
                    <span class="window-title">${this.app.name}</span>
                </div>
                <div class="window-content" id="content-${this.id}">${contentHTML}</div>
            `;
            
            this.os.dom.desktop.appendChild(this.el);
            
            // Load content based on app type
            this.loadContent();
        }
        
        loadContent() {
            const contentEl = this.el.querySelector('.window-content');
            
            if (this.app.launch) {
                // Native app with custom launch function
                contentEl.innerHTML = ''; // Clear placeholder
                contentEl.classList.add('has-content'); // Ensure proper padding/line-height
                this.app.launch(this.id); // Pass window ID to native app for content rendering
            } else if (this.app.url) {
                // iframe-based app
                contentEl.classList.add('has-iframe');
                contentEl.innerHTML = ''; // Clear placeholder
                this.iframe = document.createElement('iframe'); // Store reference to iframe
                this.iframe.src = this.app.url;
                this.iframe.onload = () => {
                    // Send appReady message from iframe to parent (desktop)
                    // The iframe itself will post 'appReady' to its parent (desktop.html)
                    // The desktop.html will then store iframeWindow on its app config
                };
                contentEl.appendChild(this.iframe);
            } else {
                // Fallback placeholder
                contentEl.classList.add('has-content');
                contentHTML = `<div class="placeholder-content">Content for ${this.app.name} will be loaded here.</div>`;
                contentEl.innerHTML = contentHTML;
            }
        }
        
        bindEvents() {
            const header = this.el.querySelector('.window-header');
            const closeBtn = this.el.querySelector('.close-btn');
            const minimizeBtn = this.el.querySelector('.minimize-btn');
            const maximizeBtn = this.el.querySelector('.maximize-btn');
            
            // Window dragging
            header.addEventListener('mousedown', (e) => {
                if (e.target.closest('.control-btn')) return;
                this.os.WindowManager.focus(this.id);
                const startX = e.clientX;
                const startY = e.clientY;
                const initialX = this.el.offsetLeft;
                const initialY = this.el.offsetTop;
                
                const doDrag = (moveEvent) => {
                    this.el.style.left = `${initialX + moveEvent.clientX - startX}px`;
                    this.el.style.top = `${initialY + moveEvent.clientY - startY}px`;
                };
                
                const stopDrag = () => { 
                    document.removeEventListener('mousemove', doDrag); 
                    document.removeEventListener('mouseup', stopDrag); 
                };
                
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', stopDrag);
            });
            
            // Close button
            closeBtn.addEventListener('click', () => this.os.WindowManager.close(this.id));
            
            // Minimize button (simple hide/show for now)
            minimizeBtn.addEventListener('click', () => {
                this.el.style.display = 'none';
                this.os.TaskbarManager.update(); // Update taskbar icon active state
                // If minimized window was active, focus another or null
                if (this.os.state.activeWindowId === this.id) {
                    const remainingWindows = Array.from(this.os.state.windows.keys()).filter(winId => this.os.state.windows.get(winId).el.style.display !== 'none' && winId !== this.id);
                    this.os.state.activeWindowId = remainingWindows.length > 0 ? remainingWindows[0] : null;
                    if (this.os.state.activeWindowId) {
                        this.os.WindowManager.focus(this.os.state.activeWindowId);
                    }
                }
            });

            // Maximize button (toggle full screen/restore)
            maximizeBtn.addEventListener('click', () => {
                if (this.el.classList.contains('maximized')) {
                    // Restore from maximized
                    this.el.style.width = this.lastWidth || '80vw';
                    this.el.style.height = this.lastHeight || '70vh';
                    this.el.style.left = this.lastLeft || 'calc(50% - 40vw)';
                    this.el.style.top = this.lastTop || 'calc(50% - 35vh)';
                    this.el.classList.remove('maximized');
                    this.el.style.resize = 'both'; // Enable resize
                } else {
                    // Maximize
                    this.lastWidth = this.el.style.width;
                    this.lastHeight = this.el.style.height;
                    this.lastLeft = this.el.style.left;
                    this.lastTop = this.el.style.top;

                    this.el.style.width = '100vw';
                    this.el.style.height = 'calc(100vh - 55px)'; // Full height minus taskbar
                    this.el.style.left = '0';
                    this.el.style.top = '0';
                    this.el.classList.add('maximized');
                    this.el.style.resize = 'none'; // Disable resize when maximized
                }
                // Important: Trigger resize on iframe content if it exists
                if (this.iframe && this.iframe.contentWindow && this.iframe.contentWindow.App && this.iframe.contentWindow.App.settings) {
                    this.iframe.contentWindow.App.settings.resizeAllEditors(); // For editor.html specifically
                }
            });
            
            // Focus on click
            this.el.addEventListener('mousedown', () => this.os.WindowManager.focus(this.id), true);
        }
        
        destroy() {  
            // Clean up iframeWindow reference in app config when window is closed
            if (this.app.iframeWindow) {
                this.app.iframeWindow = null;
            }
            this.el.remove();  
        }
    }

    /** WindowManager: Manages all window operations with support for both iframe and native apps. */
    IndexSpaceOS.WindowManager = {
        init(os) {  
            this.os = os;  
        },
        
        launchApp(app, options = {}) {
            // Check if app is already open. If so, focus it or restore it if minimized.
            for (const win of this.os.state.windows.values()) {
                if (win.app.id === app.id) {
                    if (win.el.style.display === 'none') { // If minimized
                        win.el.style.display = 'flex'; // Restore it
                    }
                    this.focus(win.id);
                    return;
                }
            }
            
            const newWindow = new Window(app, this.os, options);
            this.os.state.windows.set(newWindow.id, newWindow);
            this.focus(newWindow.id);
            this.os.TaskbarManager.update();
        },
        
        focus(id) {
            if (this.os.state.activeWindowId === id) return;
            
            this.os.state.activeWindowId = id;
            this.os.state.maxZIndex++;
            
            this.os.state.windows.forEach((win, winId) => {
                const isActive = winId === id;
                win.el.classList.toggle('active', isActive);
                if (isActive) {  
                    win.el.style.zIndex = this.os.state.maxZIndex;  
                }
            });
            
            this.os.TaskbarManager.update();
        },
        
        close(id) {
            const win = this.os.state.windows.get(id);
            if (win) {
                win.destroy();
                this.os.state.windows.delete(id);
                if (this.os.state.activeWindowId === id) {  
                    this.os.state.activeWindowId = null;  
                }
                this.os.TaskbarManager.update();
            }
        }
    };
    
    /** TaskbarManager: Renders and manages taskbar icons with intelligent filtering. */
    IndexSpaceOS.TaskbarManager = {
        init(os) {  
            this.os = os;  
            this.render();  
            this.bindEvents();  
        },
        
        render() {
            this.os.dom.taskbarIcons.innerHTML = '';
            this.os.config.apps.forEach(app => {
                // Welcome ì•±ì€ ì‘ì—… í‘œì‹œì¤„ì— í‘œì‹œí•˜ì§€ ì•ŠìŒ (ì‹œì‘ ì‹œì—ë§Œ ìë™ ì‹¤í–‰)
                if (app.id === 'welcome') return;
                
                const iconEl = document.createElement('div');
                iconEl.className = 'app-icon';
                iconEl.dataset.appId = app.id;
                iconEl.title = app.name;
                iconEl.textContent = app.icon;

                // Add notification dot placeholder for terminal
                if (app.id === 'terminal') {
                    const dot = document.createElement('div');
                    dot.id = 'terminal-notification-dot';
                    dot.className = 'notification-dot hidden'; // Initially hidden
                    iconEl.appendChild(dot);
                }

                this.os.dom.taskbarIcons.appendChild(iconEl);
            });
        },
        
        bindEvents() {
            this.os.dom.taskbarIcons.addEventListener('click', (e) => {
                const icon = e.target.closest('.app-icon');
                if (icon) {
                    const appId = icon.dataset.appId;
                    const app = this.os.config.apps.find(a => a.id === appId);
                    if (app) {  
                        this.os.WindowManager.launchApp(app);  
                    }
                }
            });
        },
        
        update() {
            const openAppIds = new Set();
            this.os.state.windows.forEach(win => {
                if (win.el.style.display !== 'none') { // Only count visible windows as "open"
                    openAppIds.add(win.app.id);
                }
            });
            
            this.os.dom.taskbarIcons.querySelectorAll('.app-icon').forEach(icon => {
                icon.classList.toggle('active', openAppIds.has(icon.dataset.appId));
            });
        }
    };
    
    // Initialize the OS when DOM is ready
    document.addEventListener('DOMContentLoaded', () => IndexSpaceOS.init());
    </script>
</body>
</html>
