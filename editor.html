<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index-Space IDE</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/ext-language_tools.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/ext-modelist.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/ext-emmet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/ext-beautify.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/keybinding-vscode.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/keybinding-sublime.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.33.0/keybinding-vim.js"></script>
    
    <script src="https://unpkg.com/prettier@2.8.8/standalone.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-babel.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-python.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-html.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-postcss.js"></script>
    
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <script src="https://unpkg.com/fengari-web/dist/fengari-web.js"></script>
    
    <style>
        /* Index-Space Theme Variables - Unified with Desktop */
        :root {
            --color-background: #0D1117;
            --color-text-primary: #E6EDF3;
            --color-text-secondary: #8B949E;
            --color-surface-1: #161B22; /* Primary background for main content */
            --color-surface-2: #0D1117; /* Darker background for sidebar/panels */
            --color-border: #30363D;
            --color-accent: #58A6FF; /* Primary accent for highlights, active states */
            --color-selection-bg: rgba(88, 166, 255, 0.2); /* Selection background */
            --color-error: #DA3633;
            --color-warning: #D29922;

            --font-family: 'Inter', sans-serif; /* Default IDE font */
            --font-mono: 'Fira Code', monospace; /* Monospaced font for code */

            /* IDE Specific Overrides - based on Index-Space Desktop theme */
            --ide-bg-primary: var(--color-background); /* Darkest background */
            --ide-bg-secondary: var(--color-surface-1); /* Editor background */
            --ide-bg-tertiary: var(--color-surface-2); /* Top bar, tabs, sidebar header */
            --ide-bg-hover: rgba(48, 54, 61, 0.5); /* Semi-transparent border color for hover */
            --ide-text-primary: var(--color-text-primary);
            --ide-text-secondary: var(--color-text-secondary);
            --ide-text-inactive: var(--color-text-secondary); /* Similar to secondary for disabled elements */
            --ide-border-primary: var(--color-border);
            --ide-accent-primary: var(--color-accent); /* Run button, active tab border */
            --ide-accent-secondary: var(--color-accent); /* Notification, other accents */
            --ide-error-color: var(--color-error);
            --ide-warning-color: var(--color-warning);
            --ide-minimap-bg: rgba(13, 17, 23, 0.7); /* Slightly darker, more transparent background */
        }

        body {
            font-family: var(--font-family);
            background-color: var(--ide-bg-primary);
            color: var(--ide-text-primary);
            overflow: hidden;
            font-size: 14px;
            user-select: none;
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--ide-bg-tertiary); }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        
        #main-grid {
            display: grid;
            grid-template-columns: 48px 250px 5px 1fr; /* Activity Bar, Sidebar, Resizer, Main View */
            grid-template-rows: 35px 1fr 5px 200px 24px; /* Top Bar, Main Editor Area, Resizer, Bottom Panel, Status Bar */
            height: 100vh;
            width: 100vw;
        }
        #top-bar {
            grid-area: 1 / 1 / 2 / 6;
            background-color: var(--ide-bg-tertiary);
            display: flex;
            align-items: center;
            padding: 0 10px;
            z-index: 60;
            border-bottom: 1px solid var(--ide-border-primary);
        }
        #activity-bar {
            grid-area: 2 / 1 / 5 / 2;
            background-color: var(--ide-bg-primary);
            z-index: 50;
            border-right: 1px solid var(--ide-border-primary);
        }
        #sidebar {
            grid-area: 2 / 2 / 5 / 3;
            background-color: var(--ide-bg-tertiary);
            z-index: 40;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--ide-border-primary);
        }
        #resizer-v {
            grid-area: 2 / 3 / 5 / 4;
            cursor: col-resize;
            z-index: 99;
            background-color: var(--ide-border-primary);
        }
        #main-view {
            grid-area: 2 / 4 / 3 / 5;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #resizer-h {
            grid-area: 3 / 4 / 4 / 5;
            cursor: row-resize;
            z-index: 99;
            background-color: var(--ide-border-primary);
        }
        #bottom-panel {
            grid-area: 4 / 4 / 5 / 5;
            background-color: var(--ide-bg-secondary);
            border-top: 1px solid var(--ide-border-primary);
        }
        #status-bar {
            grid-area: 5 / 1 / 6 / 6;
            background-color: var(--ide-accent-primary);
            color: var(--ide-bg-primary);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            font-size: 0.85rem;
        }

        /* Ace Editor Customization */
        .ace_editor { font-family: var(--font-mono) !important; background: var(--ide-bg-secondary) !important; color: var(--ide-text-primary) !important; width: 100% !important; height: 100% !important;}
        .ace_gutter { background: var(--ide-bg-secondary) !important; color: var(--ide-text-inactive) !important; }
        .ace_active-line { background: rgba(255, 255, 255, 0.05) !important; }
        .ace_cursor { color: var(--ide-text-secondary) !important; }
        .ace_selection { background: rgba(88, 166, 255, 0.25) !important; } /* Uses ide-accent-primary */
        .ace_minimap { background: var(--ide-minimap-bg); border-left: 1px solid var(--ide-border-primary); }
        .ace_minimap_slider { background: rgba(88, 166, 255, 0.2); border: 1px solid var(--ide-accent-primary); }
        .ace_error, .ace_warning { text-decoration: underline; text-decoration-style: wavy; }
        .ace_error { text-decoration-color: var(--ide-error-color); }
        .ace_warning { text-decoration-color: var(--ide-warning-color); }
        .ace_gutter-cell.ace_breakpoint { background-image: none !important; position: relative; }
        .ace_gutter-cell.ace_breakpoint::before { content: "●"; color: var(--ide-error-color); position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);}
        
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(13, 17, 23, 0.9); /* Use themed modal background */
            backdrop-filter: blur(8px);
            z-index: 1000;
            display:flex;
            align-items: flex-start;
            justify-content:center;
        }
        .modal-base {
            background: var(--ide-bg-secondary);
            margin-top:15vh;
            width: 600px;
            max-width: 90vw;
            border-radius:8px;
            box-shadow:0 10px 30px rgba(0,0,0,0.5);
            display:flex;
            flex-direction:column;
            border: 1px solid var(--ide-border-primary);
            color: var(--ide-text-primary);
        }
        .modal-input {
            background:var(--ide-bg-primary);
            border:1px solid var(--ide-border-primary);
            outline:none;
            padding:8px;
            width:100%;
            border-radius:4px;
            color: var(--ide-text-primary);
        }
        .context-menu-item:hover, .command-palette-item.active {
            background-color: var(--ide-bg-hover);
            color: var(--ide-text-primary); /* Ensure text color stays readable */
        }

        .activity-bar-icon {
            position: relative; /* For the focus indicator */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 12px 0; /* Adjust padding for better spacing */
            cursor: pointer;
            color: var(--ide-text-inactive);
            transition: all 0.2s ease;
        }
        .activity-bar-icon:hover {
            color: var(--ide-text-primary);
        }
        .activity-bar-icon.active {
            color: var(--ide-text-primary);
            box-shadow: inset 2px 0 0 var(--ide-accent-primary); /* Left border indicator */
        }
        .activity-bar-icon svg {
            width: 24px; /* Standard icon size */
            height: 24px;
            pointer-events: none; /* Allows click to pass through to parent */
        }


        .sidebar-panel, .bottom-panel-content { display: none; }
        .sidebar-panel.active, .bottom-panel-content.active { display: flex; flex-direction: column; height: 100%; }
        
        .bottom-panel-tab {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--ide-text-secondary);
            transition: all 0.2s ease;
        }
        .bottom-panel-tab:hover {
            background-color: var(--ide-bg-hover);
        }
        .bottom-panel-tab.active {
            background-color: var(--ide-bg-secondary);
            color: var(--ide-text-primary);
            border-bottom: 2px solid var(--ide-accent-primary); /* Active tab indicator */
        }

        .editor-tab {
            position: relative;
            background-color: var(--ide-bg-primary); /* Normal tab background */
            color: var(--ide-text-secondary);
            padding: 8px 12px;
            border-right: 1px solid var(--ide-border-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }
        .editor-tab:hover {
            background-color: var(--ide-bg-hover);
            color: var(--ide-text-primary);
        }
        .editor-tab.active {
            background-color: var(--ide-bg-secondary);
            color: var(--ide-text-primary);
            border-top: 2px solid var(--ide-accent-primary); /* Active tab indicator */
            padding-top: 6px; /* Adjust for border */
        }
        .editor-tab.modified .tab-name::after { content: " ●"; color: var(--ide-text-secondary); font-size: 10px; vertical-align: middle; }
        
        #editor-groups-container { display: grid; grid-template-columns: 1fr; width: 100%; height: 100%; }
        #editor-groups-container.split { grid-template-columns: 1fr 5px 1fr; }
        .editor-group {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-left: 1px solid var(--ide-border-primary); /* For split view border */
        }
        .editor-pane { flex-grow: 1; position: relative; }
        #editor-resizer-v { cursor: col-resize; background-color: var(--ide-border-primary); }

        #welcome-screen {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            background-color: var(--ide-bg-secondary);
            color: var(--ide-text-inactive);
            font-size: 1.1em;
            padding: 20px;
            flex-direction: column;
        }
        #welcome-screen h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: var(--ide-text-primary);
        }
        #welcome-screen p {
            max-width: 600px;
            line-height: 1.5;
            color: var(--ide-text-secondary);
        }
        #welcome-screen button {
            background-color: var(--ide-accent-primary);
            color: var(--ide-bg-primary);
            padding: 10px 20px;
            border-radius: 6px;
            margin-top: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        #welcome-screen button:hover {
            opacity: 0.9;
            box-shadow: 0 4px 10px rgba(88, 166, 255, 0.3);
        }

        /* File Explorer in Sidebar Specific Styles */
        .file-item {
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: var(--ide-text-primary);
            transition: background-color 0.1s ease;
        }
        .file-item:hover {
            background-color: var(--ide-bg-hover);
        }
        .file-item.selected {
            background-color: var(--color-selection-bg);
            border-left: 2px solid var(--ide-accent-primary);
            padding-left: 6px; /* Adjust padding for border */
        }
        .file-item.drag-over {
            background-color: var(--ide-accent-primary);
            color: var(--ide-bg-primary);
        }
        .file-item-icon {
            font-size: 1.1em;
            flex-shrink: 0;
        }
        .file-item-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .file-item-name.renaming {
            background: white;
            color: black;
            outline: none;
            padding: 1px 3px;
            border-radius: 3px;
            border: 1px solid var(--ide-accent-primary);
        }

        /* Context Menu Styles - Shared */
        .context-menu {
            position: fixed;
            background: var(--ide-bg-secondary);
            border: 1px solid var(--ide-border-primary);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            padding: 4px;
            z-index: 2000; /* Higher than modals */
            opacity: 0;
            transform: scale(0.95);
            transition: all 0.1s ease-out;
            pointer-events: none;
            min-width: 150px;
        }
        .context-menu.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8em;
            color: var(--ide-text-primary);
            transition: background-color 0.1s ease;
        }
        .context-menu-item:hover {
            background: var(--ide-accent-primary);
            color: white;
        }
        .context-menu-item.disabled {
            color: var(--ide-text-inactive);
            cursor: not-allowed;
            opacity: 0.6;
        }
        .context-menu-divider {
            height: 1px;
            background: var(--ide-border-primary);
            margin: 4px 0;
        }

        /* Modal Styles - Shared with Index-Space Desktop modals */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--color-modal-bg); backdrop-filter: blur(8px);
            z-index: 20000; display: flex; justify-content: center; align-items: center;
            animation: fadeIn 0.2s ease-out;
        }
        .modal-dialog {
            background: var(--color-surface-1); padding: 2rem; border-radius: 12px;
            border: 1px solid var(--color-border); text-align: center;
            max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 16px 64px rgba(0,0,0,0.5);
            animation: slideIn 0.3s ease-out;
            display: flex; flex-direction: column;
            color: var(--color-text-primary);
        }
        .modal-dialog h3 { margin-bottom: 1rem; color: var(--color-text-primary); }
        .modal-dialog p { margin-bottom: 1.5rem; color: var(--color-text-secondary); }
        .modal-dialog button {
            background: var(--color-surface-2); border: 1px solid var(--color-border);
            color: var(--color-text-primary); padding: 10px 20px; border-radius: 6px;
            cursor: pointer; margin: 0 8px; font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        .modal-dialog button:hover { background: rgba(255,255,255,0.1); }
        .modal-dialog .primary-btn { background: var(--color-accent); border-color: var(--color-accent); }
        .modal-dialog .success-btn { background: var(--color-success); border-color: var(--color-success); }
        .modal-dialog .danger-btn { background: var(--color-error); border-color: var(--color-error); }

        /* Preview Panel */
        #panel-preview iframe {
            background-color: #fff; /* Ensure white background for HTML preview */
        }

        /* Internal Terminal Styles */
        #panel-internal-terminal {
            font-family: var(--font-mono);
            font-size: 0.9em;
            line-height: 1.4;
            background-color: var(--ide-bg-secondary);
            color: var(--ide-text-primary);
            padding: 10px;
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
            overflow-y: auto;
            word-break: break-all; /* Break long words */
            position: relative; /* For loading spinner positioning */
        }
        .terminal-output-line {
            padding: 2px 0;
        }
        .terminal-output-error { color: var(--ide-error-color); }
        .terminal-output-warning { color: var(--ide-warning-color); }
        .terminal-output-info { color: var(--ide-text-secondary); }
        .terminal-output-prompt { color: var(--ide-accent-primary); }

        /* --- 로딩 스피너 및 메시지 스타일 --- */
        .terminal-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(13, 17, 23, 0.8); /* Semi-transparent dark overlay */
            display: flex; /* Flexbox for centering content */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--ide-accent-primary); /* Spinner color */
            font-size: 1.2em;
            z-index: 10; /* Above terminal output */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--ide-accent-primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .terminal-loading-message {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--ide-text-secondary);
        }
    </style>
</head>
<body>

    <div id="main-grid">
        <div id="top-bar">
            <button id="back-btn" title="Back" class="p-1.5 rounded hover:bg-[var(--ide-bg-hover)] disabled:text-[var(--ide-text-inactive)] disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
            </button>
            <button id="forward-btn" title="Forward" class="p-1.5 rounded hover:bg-[var(--ide-bg-hover)] disabled:text-[var(--ide-text-inactive)] disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>
            </button>
            <div class="w-px h-5 bg-[var(--ide-border-primary)] mx-2"></div>
            <button id="run-btn" title="Run Code (F5)" class="p-1.5 rounded hover:bg-[var(--ide-bg-hover)] disabled:text-[var(--ide-text-inactive)] disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
            </button>
            <button id="split-view-btn" title="Toggle Split View" class="p-1.5 rounded hover:bg-[var(--ide-bg-hover)]">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="3" x2="12" y2="21"></line></svg>
            </button>
        </div>

        <div id="activity-bar" class="flex flex-col items-center">
            <div data-view="explorer" class="activity-bar-icon active" title="Explorer (Ctrl+Shift+E)">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>
            </div>
            <div data-view="search" class="activity-bar-icon" title="Search (Ctrl+Shift+F)">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
            </div>
            <div data-view="settings" class="activity-bar-icon flex-grow" title="Settings">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
            </div>
        </div>
        
        <div id="sidebar">
            <div id="view-explorer" class="sidebar-panel active">
                <div class="p-2 flex justify-between items-center border-b border-[var(--ide-border-primary)]">
                    <h2 class="text-xs uppercase font-bold tracking-wider text-[var(--ide-text-secondary)]">Explorer</h2>
                    <div class="flex items-center space-x-1">
                        <button id="new-untitled-file-global" class="p-1 rounded hover:bg-[var(--ide-bg-hover)]" title="New Untitled File">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" /><path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" /></svg>
                        </button>
                        <button id="new-folder-global" class="p-1 rounded hover:bg-[var(--ide-bg-hover)]" title="New Folder">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" /></svg>
                        </button>
                    </div>
                </div>
                <div class="p-2 border-b border-[var(--ide-border-primary)]">
                    <input type="text" id="explorer-search" class="modal-input w-full text-xs" placeholder="Search files...">
                </div>
                <div id="file-explorer" class="flex-1 overflow-auto p-2"></div>
            </div>

            <div id="view-search" class="sidebar-panel">
                <div class="p-2 border-b border-[var(--ide-border-primary)]">
                    <h2 class="text-xs uppercase font-bold tracking-wider text-[var(--ide-text-secondary)] mb-2">Search</h2>
                    <input type="text" id="search-input" class="modal-input text-xs" placeholder="Search in all files...">
                </div>
                <div id="search-results" class="flex-1 overflow-auto mt-2 text-sm"></div>
            </div>

            <div id="view-settings" class="sidebar-panel p-4 overflow-y-auto">
                <h2 class="text-lg font-bold mb-4 text-[var(--ide-text-primary)]">Settings</h2>
                <div class="space-y-6">
                    <div>
                        <label for="setting-theme" class="block text-sm font-medium mb-1">Theme</label>
                        <select id="setting-theme" class="modal-input"></select>
                    </div>
                    <div>
                        <label for="setting-fontsize" class="block text-sm font-medium mb-1">Font Size</label>
                        <input type="number" id="setting-fontsize" class="modal-input w-24" min="8" max="24">
                    </div>
                    <div>
                        <label for="setting-keymap" class="block text-sm font-medium mb-1">Key Binds</label>
                        <select id="setting-keymap" class="modal-input">
                            <option value="default">Default</option>
                            <option value="vscode">VS Code</option>
                            <option value="sublime">Sublime</option>
                            <option value="vim">Vim</option>
                        </select>
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="setting-linenumbers" class="text-sm font-medium">Show Line Numbers</label>
                        <input type="checkbox" id="setting-linenumbers" class="h-4 w-4 rounded accent-[var(--ide-accent-primary)]">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="setting-minimap" class="text-sm font-medium">Show Minimap</label>
                        <input type="checkbox" id="setting-minimap" class="h-4 w-4 rounded accent-[var(--ide-accent-primary)]">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="setting-wordwrap" class="text-sm font-medium">Word Wrap</label>
                        <input type="checkbox" id="setting-wordwrap" class="h-4 w-4 rounded accent-[var(--ide-accent-primary)]">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="setting-autosave" class="text-sm font-medium">Auto Save</label>
                        <input type="checkbox" id="setting-autosave" class="h-4 w-4 rounded accent-[var(--ide-accent-primary)]">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">User Snippets (JSON)</label>
                        <div id="snippets-editor" class="w-full h-48 rounded" style="border: 1px solid var(--ide-border-primary)"></div>
                        <button id="save-snippets-btn" class="mt-2 px-3 py-1 rounded bg-[var(--ide-accent-primary)] text-[var(--ide-bg-primary)] hover:opacity-80 text-sm">Save Snippets</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="resizer-v"></div>

        <div id="main-view">
            <div id="editor-groups-container">
                <div id="editor-group-1" class="editor-group">
                    <div class="editor-tabs flex-shrink-0 flex bg-[var(--ide-bg-tertiary)] overflow-x-auto"></div>
                    <div class="editor-pane flex-1 relative"></div>
                </div>
            </div>
            <div id="welcome-screen">
                <h1>Welcome to Index-Space IDE!</h1>
                <p>Start by creating a new file or opening an existing one from the Explorer.</p>
                <button id="welcome-new-file-btn">Create New File</button>
            </div>
        </div>
        
        <div id="resizer-h"></div>
        
        <div id="bottom-panel" class="flex flex-col">
            <div class="tabs flex-shrink-0 flex bg-[var(--ide-bg-tertiary)] border-b border-[var(--ide-border-primary)] text-sm">
                <div data-panel="internal-terminal" class="bottom-panel-tab active">Terminal</div>
                <div data-panel="problems" class="bottom-panel-tab">Problems (<span id="problems-count">0</span>)</div>
                <div data-panel="preview" class="bottom-panel-tab">Preview</div>
            </div>
            <div id="panel-internal-terminal" class="bottom-panel-content flex-1 active">
                <div id="terminal-output-log"></div>
                <div id="terminal-loading-overlay" class="terminal-loading-overlay hidden">
                    <div class="spinner"></div>
                    <div id="terminal-loading-text">Loading environments...</div>
                </div>
            </div>
            <div id="panel-problems" class="bottom-panel-content flex-1 overflow-y-auto"></div>
            <div id="panel-preview" class="bottom-panel-content flex-1 overflow-y-auto">
                <iframe id="preview-frame" class="w-full h-full border-none"></iframe>
            </div>
        </div>

        <div id="status-bar">
            <div class="flex items-center gap-4">
                <button id="cmd-palette-btn" class="hover:bg-black/20 px-2 py-0.5 rounded" title="Ctrl+Shift+P">Command Palette</button>
                <button id="beta-palette-btn" class="hover:bg-black/20 px-2 py-0.5 rounded">Beta</button>
            </div>
            <div class="flex items-center gap-4"><span id="line-col"></span><span id="language-status">Plain Text</span></div>
        </div>
    </div>
    
    <div id="modal-overlay" class="overlay hidden"></div>
    <div id="context-menu" class="absolute z-[2000] bg-[var(--ide-bg-secondary)] border border-[var(--ide-border-primary)] rounded-md shadow-lg text-sm hidden py-1"></div>
    <div id="notification-toast" class="fixed bottom-4 right-4 bg-[var(--ide-accent-primary)] text-white px-4 py-2 rounded-md shadow-lg opacity-0 transition-opacity duration-300 z-[20001]"></div>
    <input type="file" id="file-importer" class="hidden" multiple>

<script type="module">
    // Define the parent iframe window reference for desktop.html communication
    let desktopIframeWindow = null; 

    const App = {
        state: {
            fs: null, 
            editors: { pane1: null, pane2: null }, 
            snippetsEditor: null, 
            activePane: 'pane1', 
            openFiles: { pane1: new Map(), pane2: new Map() }, 
            activePaths: { pane1: null, pane2: null }, 
            isSplitView: false,
            
            activeSidebarView: 'explorer', 
            activeBottomPanel: 'internal-terminal', // Default to internal terminal
            untitledCounter: 1, 
            
            settings: { 
                theme: 'Hyper Dark', 
                fontSize: 14, 
                showLineNumbers: true, 
                showMinimap: true,
                wordWrap: false, 
                autoSave: false, 
                keymap: 'default', 
                layout: { sidebar: '250px', panel: '200px', split: '1fr' } 
            },
            themes: { 
                'Hyper Dark': {}, 
                'VS Code Dark': {'--ide-bg-primary':'#1e1e1e','--ide-bg-secondary':'#252526','--ide-bg-tertiary':'#333333','--ide-text-primary':'#d4d4d4','--ide-text-secondary':'#808080'}, 
                'Solarized Light': {'--ide-bg-primary':'#fdf6e3','--ide-bg-secondary':'#f0eada','--ide-text-primary':'#657b83','--ide-text-secondary':'#93a1a1','--ide-accent-primary':'#268bd2'} 
            },
            lintResults: {}, 
            userSnippets: [], 
            autoSaveInterval: null, 
            debounceTimer: null,

            // Internal Terminal State
            pyodide: null, pyodideReady: false,
            fengari: null, // Lua environment
            luaReady: false,
        },
        dom: {}, 

        async init() {
            this.cacheDomElements();
            this.settings.init(); 
            await this.fs.init(); 
            this.snippets.init(); 
            this.editor.init(); 
            this.layout.init(); 
            this.ui.init(); 
            this.terminal.init(); // Initialize internal terminal
            this.events.init(); 
            this.search.init(); // Initialize search module
            
            this.ui.renderExplorer(); 
            this.ui.showNotification('Index-Space IDE Initialized.', 'success');

            // Listen for messages from parent (desktop.html)
            window.addEventListener('message', (event) => {
                if (event.source === window.parent && event.data && event.data.type === 'appReady' && event.data.payload.appId === 'terminal' && event.data.payload.windowId) {
                    console.log('IDE: Terminal app reported ready on desktop. Not directly connected to external terminal.');
                }
            });
            
            // Announce to parent window (desktop.html) that editor is ready
            if (window.parent) {
                window.parent.postMessage({ type: 'appReady', payload: { appId: 'editor', windowId: window.frameElement ? window.frameElement.id : null } }, '*');
            }
        },

        cacheDomElements() {
            const ids = [
                'main-grid', 'top-bar', 'run-btn', 'split-view-btn', 'activity-bar', 'sidebar', 'resizer-v', 'main-view', 'resizer-h', 
                'bottom-panel', 'status-bar', 'file-explorer', 'editor-groups-container', 'welcome-screen', 
                'context-menu', 'notification-toast', 'line-col', 'language-status', 
                'new-untitled-file-global', 'new-folder-global', 'welcome-new-file-btn',
                'modal-overlay', 'cmd-palette-btn', 'beta-palette-btn',
                'setting-theme', 'setting-fontsize', 'setting-keymap', 'setting-linenumbers', 'setting-minimap', 'setting-wordwrap', 'setting-autosave', 'snippets-editor', 'save-snippets-btn',
                'file-importer', 'view-explorer', 'view-search', 'view-settings', 
                'panel-internal-terminal', 'panel-problems', 'panel-preview', 'preview-frame', 'problems-count',
                'terminal-output-log', // 이 ID가 ids 배열에 포함되어 있는지 다시 확인
                'terminal-loading-overlay',
                'terminal-loading-text',
                'explorer-search', 'search-input', 'search-results',
                'back-btn', 'forward-btn'
            ];
            ids.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    this.dom[id.replace(/-/g, '_')] = element;
                } else {
                    console.error(`DOM element with ID '${id}' not found!`);
                    // 개발 중에는 console.error가 가장 유용합니다.
                }
            });
            
            this.dom.editor_group_1 = {
                group: document.getElementById('editor-group-1'),
                tabs: document.querySelector('#editor-group-1 .editor-tabs'),
                pane: document.querySelector('#editor-group-1 .editor-pane'),
            };
        },
        
        // --- Core Modules ---
        fs: {
            DB_NAME: 'IndexSpace_IDE_VFS_v1', // NEW DB NAME for this editor version
            DB_VERSION: 1, 
            db: null,

            init() {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    req.onupgradeneeded = e => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('nodes')) {
                            const store = db.createObjectStore('nodes', { keyPath: 'id' });
                            store.createIndex('path', ['parentId', 'name'], { unique: true });
                        }
                    };

                    req.onsuccess = async e => {
                        this.db = e.target.result;
                        await this.initDefaultFS();
                        resolve();
                    };

                    req.onerror = e => {
                        console.error("IndexedDB error:", e.target.error);
                        reject(e.target.error);
                    };
                });
            },

            async initDefaultFS() {
                let rootNode = await this._runTx('nodes', 'readonly', s => s.get('/'));
                if (!rootNode) {
                    await this._runTx('nodes', 'readwrite', s => s.add({ id: '/', type: 'folder', name: '', parentId: null, ctime: new Date(), mtime: new Date(), size: 0 }));
                }

                const defaultItems = [
                    { path: '/my-projects', type: 'folder' },
                    { path: '/my-projects/index.html', type: 'file', content: '<!DOCTYPE html>\n<html>\n<head>\n  <title>Hello Index-Space</title>\n  <style>body { font-family: "Inter", sans-serif; background-color: #1a1b26; color: #c0caf5; margin: 20px; }</style>\n</head>\n<body>\n  <h1>Welcome to Index-Space IDE!</h1>\n  <p>Edit this HTML file and see changes instantly in the Preview panel.</p>\n</body>\n</html>' },
                    { path: '/my-projects/main.py', type: 'file', content: '# Python script example\ndef greet(name):\n    print(f"Hello, {name} from Python!")\n\ngreet("Index-Space")\n\n# Press F5 or click ▶ to run this script in the Terminal.' },
                    { path: '/my-projects/script.lua', type: 'file', content: '-- Lua script example\nlocal message = "Hello, Index-Space from Lua!"\nprint(message)\n\n-- Press F5 or click ▶ to run this script in the Terminal.' },
                    { path: '/readme.md', type: 'file', content: '# Index-Space IDE\n\nThis is a browser-based Integrated Development Environment (IDE) built entirely with web technologies (HTML, CSS, JavaScript, IndexedDB).\n\n## Features:\n- **Virtual File System (VFS)**: All your files are stored locally in your browser.\n- **Code Editor**: Powered by Ace Editor with syntax highlighting, autocompletion, and themes.\n- **File Explorer**: Browse, create, rename, and delete files/folders.\n- **Run Code**: Execute Python, Lua, and JavaScript directly in the integrated Terminal.\n- **Live HTML Preview**: See your HTML changes instantly.\n- **Customizable Settings**: Adjust themes, font size, keybindings, and more.\n- **User Snippets**: Create your own code snippets.\n\nEnjoy coding!' }
                ];

                for (const item of defaultItems) {
                    if (!(await this.getNodeByPath(item.path))) {
                        try {
                            if (item.type === 'folder') {
                                await this.mkdir(item.path);
                            } else {
                                await this.write(item.path, item.content);
                            }
                        } catch (e) {
                            console.warn(`Failed to create default item ${item.path}: ${e.message}`);
                        }
                    }
                }
            },

            async _runTx(storeName, mode, operation) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction(storeName, mode);
                    const store = tx.objectStore(storeName);
                    let req;
                    try {
                        req = operation(store);
                    } catch (e) {
                        tx.abort();
                        reject(e);
                        return;
                    }
                    tx.oncomplete = () => resolve(req ? req.result : undefined);
                    tx.onerror = () => reject(tx.error);
                    tx.onabort = () => reject(tx.error);
                });
            },

            async _getNewId() { return `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; },

            async mkdir(path) {
                if (path === '/') { 
                    const existingRoot = await this.getNode('/');
                    if (!existingRoot) {
                            return this._runTx('nodes', 'readwrite', s => s.add({ id: '/', type: 'folder', name: '', parentId: null, ctime: new Date(), mtime: new Date(), size: 0 }));
                    }
                    return existingRoot.id;
                }
                const { parentPath, name } = this._parsePath(path);
                const parent = await this.getNodeByPath(parentPath);
                if (!parent || parent.type !== 'folder') throw new Error(`Invalid path: Parent folder '${parentPath}' not found or not a folder`);

                const existingNode = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, name]));
                if (existingNode) throw new Error(`An item named '${name}' already exists in '${parentPath}'`);

                const id = await this._getNewId();
                await this._runTx('nodes', 'readwrite', s => s.add({ id, parentId: parent.id, name, type: 'folder', ctime: new Date(), mtime: new Date(), size: 0 }));
                return id;
            },

            async write(path, content = '') {
                const { parentPath, name } = this._parsePath(path);
                const parent = await this.getNodeByPath(parentPath);
                if (!parent || parent.type !== 'folder') throw new Error(`Parent folder '${parentPath}' not found or not a folder`);

                let nodeData;
                let mimeType = '';
                let size = 0;

                if (content instanceof Blob) {
                    mimeType = content.type || 'application/octet-stream';
                    size = content.size;
                } else { // Assume string content
                    mimeType = 'text/plain';
                    size = new TextEncoder().encode(String(content)).length;
                }

                const existingNode = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, name]));
                const now = new Date();
                const id = existingNode ? existingNode.id : await this._getNewId();

                nodeData = {
                    id,
                    parentId: parent.id,
                    name,
                    type: 'file',
                    content,
                    size,
                    mimeType,
                    ctime: existingNode ? existingNode.ctime : now,
                    mtime: now
                };

                if (existingNode) {
                    await this._runTx('nodes', 'readwrite', s => s.put(nodeData));
                } else {
                    await this._runTx('nodes', 'readwrite', s => s.add(nodeData));
                }
                return id;
            },

            async read(id, format = 'string') {
                const node = await this.getNode(id);
                if (!node || node.type !== 'file') throw new Error('Not a file or file not found.');

                if (node.content instanceof Blob) {
                    if (format === 'blob') return node.content;
                    if (format === 'string') return await node.content.text();
                    if (format === 'dataurl') {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(node.content);
                        });
                    }
                    return node.content;
                } else { // Assume content is string
                    if (format === 'string') return String(node.content || '');
                    if (format === 'blob') return new Blob([String(node.content || '')], { type: node.mimeType || 'text/plain' });
                    if (format === 'dataurl') {
                        const blob = new Blob([String(node.content || '')], { type: node.mimeType || 'text/plain' });
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    }
                    return String(node.content || '');
                }
            },

            async list(path) {
                const p = await this.getNodeByPath(path);
                if (!p) return [];
                return this._runTx('nodes', 'readonly', s => s.index('path').getAll(IDBKeyRange.bound([p.id, ''], [p.id, '\uffff'])));
            },

            async delete(id) {
                const n = await this.getNode(id);
                if (!n) return;
                if (n.type === 'folder') {
                    const c = await this.list(await this.constructPath(id));
                    for (const i of c) await this.delete(i.id);
                }
                await this._runTx('nodes', 'readwrite', s => s.delete(id));
            },

            async rename(id, newName) {
                const nodeToRename = await this.getNode(id);
                if (!nodeToRename) throw new Error('Node not found for rename.');
                if (nodeToRename.id === '/') throw new Error("Cannot rename root folder.");

                const parent = await this.getNode(nodeToRename.parentId);
                if (parent) {
                    const existing = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, newName]));
                    if (existing && existing.id !== nodeToRename.id) {
                        throw new Error(`An item named '${newName}' already exists in this folder.`);
                    }
                }

                await this._runTx('nodes', 'readwrite', s => {
                    s.get(id).onsuccess = e => {
                        const n = e.target.result;
                        n.name = newName;
                        n.mtime = new Date();
                        s.put(n);
                    }
                });
            },

            async move(id, newParentPath) {
                const targetParent = await this.getNodeByPath(newParentPath);
                if (!targetParent || targetParent.type !== 'folder') throw new Error(`Invalid target path: '${newParentPath}' is not a folder or does not exist.`);

                const nodeToMove = await this.getNode(id);
                if (!nodeToMove) throw new Error('Node not found for move.');
                if (nodeToMove.id === '/') throw new Error("Cannot move root folder.");
                if (nodeToMove.parentId === targetParent.id) return;

                let currentCheckId = targetParent.id;
                while(currentCheckId && currentCheckId !== '/') {
                    if (currentCheckId === nodeToMove.id) {
                        throw new Error("Cannot move a folder into itself or its sub-folder.");
                    }
                    const checkNode = await this.getNode(currentCheckId);
                    currentCheckId = checkNode ? checkNode.parentId : null;
                }

                const existingNodeInTarget = await this._runTx('nodes', 'readonly', s => s.index('path').get([targetParent.id, nodeToMove.name]));
                if (existingNodeInTarget) {
                    throw new Error(`An item named '${nodeToMove.name}' already exists in the target folder.`);
                }

                await this._runTx('nodes', 'readwrite', s => {
                    s.get(id).onsuccess = e => {
                        const n = e.target.result;
                        n.parentId = targetParent.id;
                        n.mtime = new Date();
                        s.put(n);
                    }
                });
            },

            async copy(id, newParentPath) {
                const n = await this.getNode(id);
                if(!n) return;

                const targetParent = await this.getNodeByPath(newParentPath);
                if (!targetParent || targetParent.type !== 'folder') throw new Error(`Invalid target path: '${newParentPath}' is not a folder or does not exist.`);

                let newName = n.name;
                let counter = 1;
                let targetPathFull = `${newParentPath === '/' ? '' : newParentPath}/${newName}`;

                while (await this.getNodeByPath(targetPathFull)) {
                    const nameParts = n.name.split('.');
                    const baseName = nameParts.slice(0, -1).join('.');
                    const ext = nameParts.length > 1 ? `.${nameParts[nameParts.length - 1]}` : '';

                    if (counter === 1) {
                            newName = `${baseName}(Copy)${ext}`;
                    } else {
                        newName = `${baseName}(Copy ${counter})${ext}`;
                    }
                    targetPathFull = `${newParentPath === '/' ? '' : newParentPath}/${newName}`;
                    counter++;
                }

                if (n.type === 'folder') {
                    const newFolderId = await this.mkdir(`${newParentPath === '/' ? '' : newParentPath}/${newName}`);
                    const children = await this.list(await this.constructPath(id));
                    for (const child of children) {
                        await this.copy(child.id, await this.constructPath(newFolderId));
                    }
                    return newFolderId;
                } else {
                    const copiedContent = n.content instanceof Blob ? n.content : String(n.content || '');
                    const newFileId = await this.write(`${newParentPath === '/' ? '' : newParentPath}/${newName}`, copiedContent);
                    return newFileId;
                }
            },

            async getNode(id) {
                return this._runTx('nodes', 'readonly', s => s.get(id));
            },

            async getNodeByPath(path) {
                if (path === '/') return this.getNode('/');
                let pid = '/';
                let n = null;
                const pathParts = path.split('/').filter(Boolean);
                for (const name of pathParts) {
                    n = await this._runTx('nodes', 'readonly', s => s.index('path').get([pid, name]));
                    if (!n) return null;
                    pid = n.id;
                }
                return n;
            },

            async constructPath(id) {
                if (id === '/') return '/';
                let p = [];
                let n = await this.getNode(id);
                if (!n) return null;

                while (n && n.parentId !== null) {
                    p.unshift(n.name);
                    if (n.parentId === '/') break;
                    n = await this.getNode(n.parentId);
                }
                return `/${p.join('/')}`;
            },

            _parsePath(path) {
                const p = path.split('/').filter(Boolean);
                const name = p.pop() || '';
                const parentPath = `/${p.join('/')}`;
                return { parentPath: parentPath === '' ? '/' : parentPath, name };
            },

            async getAllFilePaths(dirNode, currentPath = '/') {
                if (!dirNode) { // Handle cases where dirNode might be null initially
                    dirNode = await this.getNodeByPath('/'); // Try to get root
                    if (!dirNode) return []; // If root doesn't exist, no paths
                }

                let filePaths = [];
                const children = await this.list(currentPath); // Get children directly from VFS for currentPath
                
                for (const node of children) {
                    const fullPath = `${currentPath === '/' ? '' : currentPath}/${node.name}`;
                    if (node.type === 'file') {
                        filePaths.push(fullPath);
                    } else if (node.type === 'folder') {
                        filePaths = filePaths.concat(await this.getAllFilePaths(node, fullPath)); // Recursive call with actual node
                    }
                }
                return filePaths;
            },
            async findNodesByContent(query, currentSearchPath = '/') {
                const results = [];
                const lowerCaseQuery = query.toLowerCase();
                // This needs to iterate through all files, potentially recursively
                const allPaths = await this.getAllFilePaths(await this.getNodeByPath(currentSearchPath), currentSearchPath);

                for(const path of allPaths) {
                    const node = await this.getNodeByPath(path);
                    if (node && node.type === 'file' && node.mimeType && node.mimeType.startsWith('text/')) {
                        try {
                            const contentString = await this.read(node.id, 'string');
                            if (contentString.toLowerCase().includes(lowerCaseQuery)) {
                                results.push(node);
                            }
                        } catch (readError) {
                            console.warn(`Could not read content for search: ${node.name}`, readError);
                        }
                    }
                }
                return results;
            }
        }, 
        
        settings: {
            init() {
                const saved = localStorage.getItem('indexspace_ide_settings_v1');
                if (saved) {
                    const parsedSettings = JSON.parse(saved);
                    App.state.settings = { ...App.state.settings, ...parsedSettings, layout: { ...App.state.settings.layout, ...parsedSettings.layout }};
                }
                this.populateUI();
                this.applyAll();
            },
            save() { localStorage.setItem('indexspace_ide_settings_v1', JSON.stringify(App.state.settings)); },
            populateUI() {
                App.dom.setting_theme.innerHTML = Object.keys(App.state.themes).map(t => `<option value="${t}">${t}</option>`).join('');
                App.dom.setting_theme.value = App.state.settings.theme;
                App.dom.setting_fontsize.value = App.state.settings.fontSize;
                App.dom.setting_keymap.value = App.state.settings.keymap;
                App.dom.setting_linenumbers.checked = App.state.settings.showLineNumbers;
                App.dom.setting_minimap.checked = App.state.settings.showMinimap;
                App.dom.setting_wordwrap.checked = App.state.settings.wordWrap;
                App.dom.setting_autosave.checked = App.state.settings.autoSave;
            },
            applyAll() {
                const theme = App.state.themes[App.state.settings.theme] || {};
                const baseTheme = {'--ide-bg-primary':'#0D1117','--ide-bg-secondary':'#161B22','--ide-bg-tertiary':'#0D1117','--ide-text-primary':'#E6EDF3','--ide-text-secondary':'#8B949E','--ide-text-inactive':'#8B949E','--ide-border-primary':'#30363D','--ide-accent-primary':'#58A6FF','--ide-accent-secondary':'#58A6FF','--ide-error-color':'#DA3633','--ide-warning-color':'#D29922','--ide-minimap-bg':'rgba(13, 17, 23, 0.7)'};
                Object.entries(baseTheme).forEach(([key,val]) => document.documentElement.style.setProperty(key, val));
                Object.entries(theme).forEach(([key,val]) => document.documentElement.style.setProperty(key, val));
                
                const options = { 
                    fontSize: App.state.settings.fontSize + 'px', 
                    showGutter: App.state.settings.showLineNumbers,
                    showMinimap: App.state.settings.showMinimap,
                    wrap: App.state.settings.wordWrap,
                };
                Object.values(App.state.editors).forEach(editor => {
                    if (editor) {
                        editor.setOptions(options);
                        editor.setKeyboardHandler(App.state.settings.keymap === 'default' ? null : `ace/keyboard/${App.state.settings.keymap}`);
                    }
                });

                if (App.state.settings.autoSave) {
                    if (!App.state.autoSaveInterval) {
                        App.state.autoSaveInterval = setInterval(() => {
                            Object.keys(App.state.editors).forEach(paneId => {
                                if (App.state.activePaths[paneId]) App.files.save(paneId);
                            });
                        }, 2000);
                    }
                } else {
                    clearInterval(App.state.autoSaveInterval);
                    App.state.autoSaveInterval = null;
                }

                App.dom.main_grid.style.gridTemplateColumns = `48px ${App.state.settings.layout.sidebar} 5px 1fr`;
                App.dom.main_grid.style.gridTemplateRows = `35px 1fr 5px ${App.state.settings.layout.panel} 24px`;
                
                this.resizeAllEditors();
            },
            update(key, value) { App.state.settings[key] = value; this.applyAll(); this.save(); },
            resizeAllEditors() {
                setTimeout(() => {
                    Object.values(App.state.editors).filter(Boolean).forEach(editor => editor?.resize());
                    App.state.snippetsEditor?.resize();
                }, 10);
            }
        },
        
        editor: {
            init() {
                this.createEditorInstance('pane1');
                // Ensure snippets-editor element exists before creating the Ace editor instance
                if (App.dom.snippets_editor) {
                    App.state.snippetsEditor = this.createSnippetsEditor();
                } else {
                    console.warn("Snippets editor element not found. Snippets functionality may be limited.");
                }
            },
            createEditorInstance(paneId) {
                const domInfo = App.ui.getPaneDom(paneId);
                const editor = ace.edit(domInfo.pane);
                
                editor.setOptions({
                    enableBasicAutocompletion: true, enableLiveAutocompletion: true, enableSnippets: true,
                    showPrintMargin: false, highlightActiveLine: true, fontFamily: 'var(--font-mono)', 
                    theme: 'ace/theme/tomorrow_night_eighties', enableEmmet: true, selectionStyle: "line"
                });

                editor.on("focus", () => App.state.activePane = paneId);
                editor.on("changeSelection", () => App.ui.updateStatus());
                editor.on("change", () => {
                    const path = App.state.activePaths[paneId];
                    if (path) {
                        const data = App.state.openFiles[paneId].get(path);
                        if (data && !data.tabEl.classList.contains('modified')) data.tabEl.classList.add('modified');
                        clearTimeout(App.state.debounceTimer);
                        App.state.debounceTimer = setTimeout(() => {
                            const content = editor.getValue();
                            App.linter.lintFile(path, content);
                            App.preview.update(path, content);
                        }, 500);
                    }
                });

                App.state.editors[paneId] = editor;
                this.setupCommands(editor);
                App.settings.applyAll();
                return editor;
            },
            createSnippetsEditor() {
                const editor = ace.edit("snippets-editor");
                editor.setOptions({
                    mode: "ace/mode/json", showGutter: false, fontSize: "12px",
                    theme: 'ace/theme/tomorrow_night_eighties',
                });
                editor.setValue(JSON.stringify(App.snippets.get(), null, 2), 1);
                return editor;
            },
            getActiveEditor() { return App.state.editors[App.state.activePane]; },
            setupCommands(editor) {
                const commands = [
                    { name: "save", bindKey: {win: "Ctrl-S", mac: "Command-S"}, exec: () => App.files.save() },
                    { name: "run", bindKey: {win: "F5", mac: "F5"}, exec: () => App.files.runActive() },
                    { name: 'format', bindKey: { win: 'Shift-Alt-F', mac: 'Shift-Option-F' }, exec: (editor) => App.formatter.formatCode(editor) },
                    { name: "togglecomment", bindKey: {win: "Ctrl-/", mac: "Command-/"}, exec: editor => editor.toggleCommentLines() },
                    { name: "duplicateline", bindKey: {win: "Ctrl-Shift-D", mac: "Command-Shift-D"}, exec: editor => editor.duplicateSelection() },
                    { name: "movelinesup", bindKey: {win: "Alt-Up", mac: "Option-Up"}, exec: (e) => e.moveLinesUp() },
                    { name: "movelinesdown", bindKey: {win: "Alt-Down", mac: "Option-Down"}, exec: (e) => e.moveLinesDown() },
                    { name: "addcursorup", bindKey: {win: "Ctrl-Alt-Up", mac: "Command-Option-Up"}, exec: (e) => e.selectMoreLines(-1) },
                    { name: "addcursordown", bindKey: {win: "Ctrl-Alt-Down", mac: "Command-Option-Down"}, exec: (e) => e.selectMoreLines(1) },
                ];
                commands.forEach(cmd => editor.commands.addCommand(cmd));
            }
        },
        
        ui: {
            init() {
                this.switchSidebarView('explorer'); 
                this.switchBottomPanel('internal-terminal'); // Default to internal terminal
            },
            getPaneDom(paneId) {
                if (paneId === 'pane1') return App.dom.editor_group_1;
                return {
                    group: document.getElementById('editor-group-2'),
                    tabs: document.querySelector('#editor-group-2 .editor-tabs'),
                    pane: document.querySelector('#editor-group-2 .editor-pane'),
                };
            },
            async renderExplorer() {
                const container = App.dom.file_explorer; 
                if (!container) {
                    console.error("File explorer container not found, cannot render explorer.");
                    return;
                }
                container.innerHTML = '';
                const query = App.dom.explorer_search?.value.toLowerCase() || ''; // Add nullish coalescing for safety
                
                const render = async (parentId, pathPrefix = '', level = 0) => {
                    let items = await App.fs.list(pathPrefix || '/'); // Fetch children from VFS

                    const itemsWithMatchStatus = await Promise.all(items.map(async item => {
                        const nameMatches = item.name.toLowerCase().includes(query);
                        let contentMatches = false;
                        if (item.type === 'folder' && query) { // Only search content if there's a query
                            const folderPath = `${pathPrefix === '/' ? '' : pathPrefix}/${item.name}`;
                            const foundInContent = await App.fs.findNodesByContent(query, folderPath);
                            contentMatches = foundInContent && foundInContent.length > 0;
                        }
                        return { item, matches: nameMatches || contentMatches };
                    }));

                    const filteredItems = itemsWithMatchStatus
                        .filter(entry => entry.matches)
                        .map(entry => entry.item);

                    // Sort items: folders first, then files, both alphabetically
                    filteredItems.sort((a, b) => {
                        if (a.type === 'folder' && b.type !== 'folder') return -1;
                        if (a.type !== 'folder' && b.type === 'folder') return 1;
                        return a.name.localeCompare(b.name);
                    }).forEach(async (node) => { // Use async forEach if there are awaits inside
                        const path = await App.fs.constructPath(node.id);
                        const el = document.createElement('div');
                        el.className = 'file-item p-1 rounded cursor-pointer flex items-center hover:bg-[var(--ide-bg-hover)]';
                        el.style.paddingLeft = `${level * 16 + 4}px`;
                        el.dataset.path = path;
                        el.dataset.id = node.id;
                        el.draggable = true;
                        
                        const icon = node.type === 'folder' ? (node.isOpen ? '📂' : '📁') : '📄';
                        el.innerHTML = `<span class="mr-2 pointer-events-none">${icon}</span><span class="pointer-events-none">${node.name}</span>`;
                        container.appendChild(el);
                        
                        el.addEventListener('click', (e) => {
                            e.stopPropagation();
                            if (node.type === 'folder') { 
                                node.isOpen = !node.isOpen; 
                                App.ui.renderExplorer(); 
                            } else { 
                                App.files.open(path); 
                            }
                        });
                        
                        el.addEventListener('dragstart', (e) => { 
                            e.stopPropagation(); 
                            e.dataTransfer.setData('text/plain', JSON.stringify({type: 'move', id: node.id})); 
                            e.dataTransfer.effectAllowed = 'move';
                        });
                        el.addEventListener('dragover', (e) => { 
                            e.preventDefault(); 
                            e.stopPropagation(); 
                            if(node.type === 'folder') el.classList.add('drag-over'); 
                        });
                        el.addEventListener('dragleave', (e) => { 
                            e.preventDefault(); 
                            e.stopPropagation(); 
                            el.classList.remove('drag-over'); 
                        });
                        el.addEventListener('drop', async (e) => {
                            e.preventDefault(); e.stopPropagation();
                            el.classList.remove('drag-over');
                            
                            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                            if (data.type === 'move' && data.id) {
                                const srcId = data.id;
                                const destId = node.type === 'folder' ? node.id : node.parentId; 
                                const destPath = await App.fs.constructPath(destId);

                                if (srcId === destId) return; 

                                try {
                                    await App.fs.move(srcId, destPath);
                                    App.ui.showNotification(`Moved ${node.name} to ${destPath}`, 'success');
                                    App.ui.renderExplorer();
                                } catch (err) {
                                    App.ui.showNotification(`Move failed: ${err.message}`, 'error');
                                }
                            }
                        });

                        if (node.type === 'folder' && node.isOpen) {
                            await render(node.id, path, level + 1); 
                        }
                    });
                };
                const rootNode = await App.fs.getNodeByPath('/'); 
                if (rootNode) {
                    await render(rootNode.id, '/', 0); 
                } else {
                    console.warn("Root file system node not found. File explorer might be empty.");
                }
            },
            updateStatus() {
                const editor = App.editor.getActiveEditor();
                const paneId = App.state.activePane;
                if (!editor || !paneId) return;
                const path = App.state.activePaths[paneId];
                if (!path) { App.dom.line_col.textContent = ''; App.dom.language_status.textContent = ''; return; }
                
                const pos = editor.getCursorPosition();
                if (App.dom.line_col) { // Add null check for safety
                    App.dom.line_col.textContent = `Ln ${pos.row + 1}, Col ${pos.column + 1}`;
                }
                if (App.dom.language_status) { // Add null check for safety
                    App.dom.language_status.textContent = ace.require("ace/ext/modelist").getModeForPath(path).caption;
                }
            },
            switchSidebarView(viewId) {
                if (!App.dom.sidebar || !App.dom.main_grid || !App.dom.resizer_v) {
                    console.error("Sidebar or grid elements not found for switchSidebarView.");
                    return;
                }

                if (App.state.activeSidebarView === viewId && App.dom.sidebar.style.display !== 'none') {
                    App.dom.main_grid.style.gridTemplateColumns = '48px 0px 0px 1fr';
                    App.dom.sidebar.style.display = 'none';
                    App.dom.resizer_v.style.display = 'none';
                } else {
                    App.dom.main_grid.style.gridTemplateColumns = `48px ${App.state.settings.layout.sidebar} 5px 1fr`;
                    App.dom.sidebar.style.display = 'flex';
                    App.dom.resizer_v.style.display = 'block';
                    document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));
                    document.getElementById(`view-${viewId}`)?.classList.add('active');
                    document.querySelectorAll('.activity-bar-icon').forEach(i => i.classList.remove('active'));
                    document.querySelector(`.activity-bar-icon[data-view="${viewId}"]`)?.classList.add('active');
                }
                App.state.activeSidebarView = viewId;
                App.settings.resizeAllEditors();
            },
            switchBottomPanel(panelId) {
                if (!App.dom.bottom_panel || !App.dom.resizer_h || !App.dom.main_grid) {
                    console.error("Bottom panel or grid elements not found for switchBottomPanel.");
                    return;
                }

                App.dom.bottom_panel.style.display = 'flex';
                App.dom.resizer_h.style.display = 'block';
                App.dom.main_grid.style.gridTemplateRows = `35px 1fr 5px ${App.state.settings.layout.panel} 24px`;
                document.querySelectorAll('.bottom-panel-content').forEach(p => p.classList.remove('active'));
                document.getElementById(`panel-${panelId}`)?.classList.add('active');
                document.querySelectorAll('.bottom-panel-tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.bottom-panel-tab[data-panel="${panelId}"]`)?.classList.add('active');
                App.state.activeBottomPanel = panelId;
                App.settings.resizeAllEditors();
            },
            toggleBottomPanel() {
                if (!App.dom.bottom_panel || !App.dom.resizer_h || !App.dom.main_grid) {
                    console.error("Bottom panel or grid elements not found for toggleBottomPanel.");
                    return;
                }

                const isVisible = App.dom.bottom_panel.style.display !== 'none';
                if (isVisible) {
                    App.dom.bottom_panel.style.display = 'none';
                    App.dom.resizer_h.style.display = 'none';
                    App.dom.main_grid.style.gridTemplateRows = '35px 1fr 0px 0px 24px';
                } else {
                    this.switchBottomPanel(App.state.activeBottomPanel);
                }
                App.settings.resizeAllEditors();
            },
            showNotification(msg, type = 'success') {
                const toast = App.dom.notification_toast; 
                if (!toast) {
                    console.warn("Notification toast element not found.");
                    return;
                }
                toast.textContent = msg;
                toast.style.backgroundColor = type === 'error' ? 'var(--ide-error-color)' : (type === 'warning' ? 'var(--ide-warning-color)' : 'var(--ide-accent-primary)');
                toast.classList.remove('opacity-0');
                setTimeout(() => toast.classList.add('opacity-0'), 3000);
            },
            showModal(content) {
                if (!App.dom.modal_overlay) {
                    console.error("Modal overlay element not found, cannot show modal.");
                    return;
                }
                App.dom.modal_overlay.innerHTML = ''; 
                App.dom.modal_overlay.appendChild(content);
                App.dom.modal_overlay.classList.remove('hidden');
            },
            hideModal() { 
                if (App.dom.modal_overlay) {
                    App.dom.modal_overlay.classList.add('hidden'); 
                } else {
                    console.warn("Modal overlay element not found, cannot hide modal.");
                }
            },
            // Helper function to get node from explorer; might need to be async if it queries DB
            getCurrentNodeFromExplorer(nodeId) {
                // For simplicity, assuming nodes in explorer are kept in a local structure or can be quickly retrieved.
                // If this needs to hit IndexedDB, it should be async.
                // For now, let's just return a dummy type based on the ID for context menu, or make it async and fetch from App.fs
                // This is a placeholder, you might need to implement actual logic to retrieve the node object from your VFS.
                // For a robust solution, you might query App.fs.getNode(nodeId) here (making showContextMenu async).
                // But for now, we'll simulate based on common IDs.
                if (nodeId === '/') return { type: 'folder' };
                if (nodeId && nodeId.includes('file-')) return { type: 'file' }; // Dummy check for example
                if (nodeId && nodeId.includes('folder-')) return { type: 'folder' }; // Dummy check for example
                
                // Fallback: If target element has a dataset.path, try to infer type from extension or fetch from FS
                const selectedEl = document.querySelector(`.file-item[data-id="${nodeId}"]`);
                if (selectedEl && selectedEl.dataset.path) {
                    const path = selectedEl.dataset.path;
                    const parts = path.split('.');
                    const ext = parts[parts.length - 1];
                    if (['py', 'js', 'html', 'lua', 'md', 'txt'].includes(ext)) {
                        return { type: 'file' };
                    }
                    // This is a weak inference. A stronger solution would be to await App.fs.getNode(nodeId)
                    // and use its actual `type` property.
                }
                return null;
            }
        },
        
        layout: {
            init() {
                const onDrag = (resizer, onMove, onEnd) => resizer?.addEventListener('mousedown', e => { // Add nullish coalescing
                    e.preventDefault(); 
                    const cb = (ev)=>onMove(ev); 
                    const upCb = () => { 
                        document.removeEventListener('mousemove', cb); 
                        if(onEnd) onEnd(); 
                    }; 
                    document.addEventListener('mousemove', cb); 
                    document.addEventListener('mouseup', upCb, { once: true }); 
                });
                
                // Add null checks for resizers before attaching event listeners
                if (App.dom.resizer_v) {
                    onDrag(App.dom.resizer_v, e => {
                        const newSidebarWidth = e.clientX - 48; 
                        if (newSidebarWidth > 150 && newSidebarWidth < window.innerWidth / 2) { 
                            App.dom.main_grid.style.gridTemplateColumns = `48px ${newSidebarWidth}px 5px 1fr`;
                        }
                    }, () => {
                        App.state.settings.layout.sidebar = App.dom.main_grid.style.gridTemplateColumns.split(' ')[1];
                        App.settings.save();
                        App.settings.resizeAllEditors();
                    });
                } else {
                    console.warn("Vertical resizer (resizer_v) not found.");
                }

                if (App.dom.resizer_h) {
                    onDrag(App.dom.resizer_h, e => {
                        const newPanelHeight = window.innerHeight - e.clientY - 24; 
                        if (newPanelHeight > 100 && newPanelHeight < window.innerHeight / 2) { 
                            App.dom.main_grid.style.gridTemplateRows = `35px 1fr 5px ${newPanelHeight}px 24px`;
                        }
                    }, () => {
                        App.state.settings.layout.panel = App.dom.main_grid.style.gridTemplateRows.split(' ')[3];
                        App.settings.save();
                        App.settings.resizeAllEditors();
                    });
                } else {
                    console.warn("Horizontal resizer (resizer_h) not found.");
                }
            },
            toggleSplitView() {
                if (!App.dom.editor_groups_container) {
                    console.error("Editor groups container not found, cannot toggle split view.");
                    return;
                }

                App.state.isSplitView = !App.state.isSplitView;
                const container = App.dom.editor_groups_container;
                if (App.state.isSplitView) {
                    container.classList.add('split');
                    const group2HTML = `<div id="editor-group-2" class="editor-group"><div class="editor-tabs flex-shrink-0 flex bg-[var(--ide-bg-tertiary)] overflow-x-auto"></div><div class="editor-pane flex-1 relative"></div></div>`;
                    const resizerHTML = `<div id="editor-resizer-v-editor"></div>`; // Renamed for clarity, to avoid conflict with main resizer-v
                    // Insert adjacent HTML; must ensure the element exists
                    if (App.dom.editor_group_1?.group) {
                         App.dom.editor_group_1.group.insertAdjacentHTML('afterend', resizerHTML + group2HTML);
                         // Re-cache specific elements after they are added to DOM
                         App.dom.editor_resizer_v_editor = document.getElementById('editor-resizer-v-editor');
                    } else {
                        console.error("editor-group-1 not found for split view creation.");
                        App.state.isSplitView = false; // Revert state if creation failed
                        return;
                    }
                   
                    App.dom.editor_group_2 = {
                        group: document.getElementById('editor-group-2'),
                        tabs: document.querySelector('#editor-group-2 .editor-tabs'),
                        pane: document.querySelector('#editor-group-2 .editor-pane'),
                    };
                    App.editor.createEditorInstance('pane2');
                    App.state.activePane = 'pane2'; 
                    App.state.editors.pane2.focus();

                    // Add drag logic for the new editor-specific resizer
                    if (App.dom.editor_resizer_v_editor) {
                        const editorResizer = App.dom.editor_resizer_v_editor;
                        editorResizer.style.backgroundColor = 'var(--ide-border-primary)'; // Apply style
                        editorResizer.style.cursor = 'col-resize'; // Apply cursor
                        
                        editorResizer.addEventListener('mousedown', e => {
                            e.preventDefault();
                            const editorGroup1 = App.dom.editor_group_1.group;
                            const editorGroup2 = App.dom.editor_group_2.group;
                            const startX = e.clientX;
                            const initialWidth1 = editorGroup1.offsetWidth;
                            const initialWidth2 = editorGroup2.offsetWidth;
                            const containerWidth = editorGroup1.parentElement.offsetWidth; // editor-groups-container

                            const onMouseMove = (moveEvent) => {
                                const deltaX = moveEvent.clientX - startX;
                                let newWidth1 = initialWidth1 + deltaX;
                                let newWidth2 = initialWidth2 - deltaX;

                                // Prevent pane from becoming too small
                                const minWidth = 100; 
                                if (newWidth1 < minWidth) {
                                    newWidth1 = minWidth;
                                    newWidth2 = containerWidth - newWidth1 - editorResizer.offsetWidth;
                                }
                                if (newWidth2 < minWidth) {
                                    newWidth2 = minWidth;
                                    newWidth1 = containerWidth - newWidth2 - editorResizer.offsetWidth;
                                }

                                editorGroup1.style.flexBasis = `${newWidth1}px`;
                                editorGroup2.style.flexBasis = `${newWidth2}px`;
                                editorGroup1.style.flexGrow = '0'; // Fix flex-grow to maintain sizes during drag
                                editorGroup2.style.flexGrow = '0';
                            };

                            const onMouseUp = () => {
                                document.removeEventListener('mousemove', onMouseMove);
                                document.removeEventListener('mouseup', onMouseUp);
                                // Reset flex-grow to 1 to allow resizing with window, but retain proportions
                                App.dom.editor_group_1.group.style.flexGrow = '1';
                                App.dom.editor_group_2.group.style.flexGrow = '1';
                                App.settings.resizeAllEditors();
                            };

                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', onMouseUp);
                        });
                    }

                } else {
                    container.classList.remove('split');
                    // Merge pane2 files into pane1 before removing pane2
                    App.state.openFiles.pane2.forEach((fileData, path) => {
                        // Only open if not already open in pane1 to avoid duplicates
                        if (!App.state.openFiles.pane1.has(path)) {
                            App.files.open(path, 'pane1', fileData.isUntitled, fileData.session.getValue());
                        }
                    });
                    document.getElementById('editor-group-2')?.remove();
                    document.getElementById('editor-resizer-v-editor')?.remove(); // Remove the editor-specific resizer
                    App.state.editors.pane2 = null;
                    App.state.openFiles.pane2.clear();
                    App.state.activePaths.pane2 = null;
                    App.state.activePane = 'pane1'; 
                    // Set focus back to pane1's current active file, or first file if available
                    if (App.state.openFiles.pane1.size > 0) {
                        App.files.switch([...App.state.openFiles.pane1.keys()][App.state.openFiles.pane1.size -1], 'pane1'); 
                    } else {
                        // If pane1 also has no open files, show welcome screen
                        App.dom.welcome_screen.style.display = 'flex';
                    }
                }
                App.settings.resizeAllEditors();
            }
        },

        files: {
            async open(path, paneId = App.state.activePane, isUntitled = false, content = '') {
                // Ensure targetPaneId is valid even if split view is toggled off
                const targetPaneId = App.state.isSplitView ? paneId : 'pane1';

                // If trying to open in pane2 but split view is off, toggle it on first
                if (paneId === 'pane2' && !App.state.isSplitView) { 
                    App.layout.toggleSplitView(); 
                }

                // If file is already open in the target pane, just switch to it
                if (App.state.openFiles[targetPaneId].has(path)) return this.switch(path, targetPaneId);
                
                let fileContent = content;
                if (!isUntitled) {
                    try {
                        const file = await App.fs.getNodeByPath(path);
                        if (!file || file.type !== 'file') {
                            App.ui.showNotification(`Could not open: ${path}. Not a file or not found.`, 'error');
                            return;
                        }
                        // For non-text files (e.g., images), we should not attempt to read as string directly for Ace editor.
                        // For this IDE, assuming most files opened in editor are text-based.
                        // If it's a binary file, content will be a Blob, and Ace editor can't display it.
                        // You might want a different handler for binary files (e.g., download or image preview)
                        if (file.mimeType && !file.mimeType.startsWith('text/')) {
                            App.ui.showNotification(`Cannot open binary file '${file.name}' in editor.`, 'warning');
                            return;
                        }
                        fileContent = await App.fs.read(file.id, 'string');
                    } catch (error) {
                        App.ui.showNotification(`Error reading file ${path}: ${error.message}`, 'error');
                        return;
                    }
                }
                
                if (App.dom.welcome_screen) { // Check if welcome screen element exists
                    App.dom.welcome_screen.style.display = 'none';
                }

                const modelist = ace.require("ace/ext/modelist");
                const mode = modelist.getModeForPath(path).mode;
                const session = ace.createEditSession(fileContent, mode);
                App.linter.setAnnotations(session, path);

                const tabEl = document.createElement('div');
                tabEl.className = 'editor-tab px-4 py-2 border-r border-[var(--ide-border-primary)] cursor-pointer flex items-center gap-2 flex-shrink-0';
                tabEl.dataset.path = path; tabEl.title = path;
                const fileName = path.split('/').pop();
                tabEl.innerHTML = `<span class="tab-name">${fileName}</span><span class="close-tab text-xs p-0.5 rounded-full hover:bg-black/20" title="Ctrl+Shift+W">x</span>`;
                
                const domInfo = App.ui.getPaneDom(targetPaneId);
                if (domInfo.tabs) { // Check if tabs element exists
                    domInfo.tabs.appendChild(tabEl);
                } else {
                    console.error(`Editor tabs element for pane '${targetPaneId}' not found.`);
                    return;
                }
                
                tabEl.onclick = () => this.switch(path, targetPaneId);
                const closeButton = tabEl.querySelector('.close-tab');
                if (closeButton) {
                    closeButton.onclick = (e) => { e.stopPropagation(); this.close(path, false, targetPaneId); };
                } else {
                    console.warn("Close tab button not found for new tab.");
                }
                
                App.state.openFiles[targetPaneId].set(path, { session, tabEl, isUntitled });
                this.switch(path, targetPaneId);
                App.linter.lintFile(path, fileContent);
                App.preview.update(path, fileContent);
            },
            openUntitled(lang = 'js') {
                const ext = lang;
                const path = `Untitled-${App.state.untitledCounter++}.${ext}`;
                const templates = {
                    js: '// New JavaScript File',
                    py: '# New Python File',
                    lua: '-- New Lua File',
                    html: '<!DOCTYPE html>\n<html>\n<head>\n  <title>New HTML File</title>\n</head>\n<body>\n\n</body>\n</html>',
                };
                this.open(path, App.state.activePane, true, templates[ext]);
            },
            switch(path, paneId) {
                if (App.state.activePaths[paneId] === path) return;
                const oldPath = App.state.activePaths[paneId];
                if(oldPath && App.state.openFiles[paneId].has(oldPath)) {
                    App.state.openFiles[paneId].get(oldPath).tabEl.classList.remove('active');
                }
                
                App.state.activePaths[paneId] = path;
                const data = App.state.openFiles[paneId].get(path);
                if (!data) {
                    console.error(`No file data found for path: ${path} in pane: ${paneId}`);
                    // Optionally close the tab if data is missing or switch to another valid tab
                    this.close(path, true, paneId); 
                    return;
                }
                data.tabEl.classList.add('active');
                App.state.editors[paneId].setSession(data.session);
                App.state.editors[paneId].focus();
                this.updateRunButtonState(path);
                App.ui.updateStatus();
                App.preview.update(path, data.session.getValue());
            },
            close(path, force = false, paneId) {
                if (!paneId || !App.state.openFiles[paneId]) return;
                const data = App.state.openFiles[paneId].get(path); if (!data) return;
                if (data.tabEl.classList.contains('modified') && !force) {
                    if(!confirm(`'${path}' has unsaved changes. Close anyway?`)) return;
                }
                const domInfo = App.ui.getPaneDom(paneId);
                if (domInfo.tabs && data.tabEl) { // Check before attempting to removeChild
                    domInfo.tabs.removeChild(data.tabEl); 
                } else {
                    console.warn(`Could not remove tab element for path ${path} in pane ${paneId}.`);
                }
                App.state.openFiles[paneId].delete(path);
                
                if (App.state.activePaths[paneId] === path) {
                    const remainingPaths = [...App.state.openFiles[paneId].keys()];
                    const nextPath = remainingPaths.pop();
                    if (nextPath) this.switch(nextPath, paneId);
                    else {
                        App.state.activePaths[paneId] = null;
                        if(App.state.openFiles.pane1.size === 0 && (!App.state.isSplitView || App.state.openFiles.pane2.size === 0)) {
                           if (App.dom.welcome_screen) { // Check if welcome screen element exists
                               App.dom.welcome_screen.style.display = 'flex';
                           }
                        }
                        if (App.state.activePane === paneId) this.updateRunButtonState(null);
                        App.ui.updateStatus();
                        App.preview.update(null, ''); // Clear preview
                    }
                }
            },
            async save(paneId) {
                const targetPaneId = paneId || App.state.activePane;
                const path = App.state.activePaths[targetPaneId];
                if (!path) return;
                const data = App.state.openFiles[targetPaneId].get(path); if (!data) return;
                if (data.isUntitled) { App.events.showSaveAsModal(path, targetPaneId); return; }
                
                const fileNode = await App.fs.getNodeByPath(path);
                const newContent = data.session.getValue();
                
                let originalContent = '';
                if (fileNode) {
                    originalContent = await App.fs.read(fileNode.id, 'string');
                }

                if(originalContent !== newContent) {
                    try {
                        await App.fs.write(path, newContent);
                        if (data.tabEl) { // Check if tabEl exists
                            data.tabEl.classList.remove('modified');
                        }
                        App.linter.lintFile(path, newContent);
                        App.preview.update(path, newContent);
                        if (!App.state.settings.autoSave) App.ui.showNotification(`${path.split('/').pop()} saved.`, 'success');
                    } catch (error) {
                        App.ui.showNotification(`Failed to save ${path.split('/').pop()}: ${error.message}`, 'error');
                        console.error('Save error:', error);
                    }
                } else {
                    if (data.tabEl) { // Check if tabEl exists
                       data.tabEl.classList.remove('modified');
                    }
                }
            },
            async runActive() {
                const paneId = App.state.activePane;
                const path = App.state.activePaths[paneId];
                if (!path) return App.ui.showNotification('No active file to run.', 'error');
                
                await this.save(paneId); // Auto-save before running

                const ext = path.split('.').pop();
                const languageMap = { 'js': 'javascript', 'py': 'python', 'lua': 'lua', 'html': 'html' };
                const language = languageMap[ext];

                if (language) {
                    // Check environment readiness before running
                    if (language === 'python' && !App.terminal.state.pyodideReady) {
                        return App.ui.showNotification('Python environment is still loading. Please wait.', 'warning');
                    }
                    if (language === 'lua' && !App.terminal.state.luaReady) {
                        return App.ui.showNotification('Lua environment is still loading. Please wait.', 'warning');
                    }

                    const content = App.state.openFiles[paneId].get(path).session.getValue();
                    App.terminal.runScriptContent(language, content, path); // Run in internal terminal
                    App.ui.switchBottomPanel('internal-terminal'); // Switch to internal terminal panel
                    // Notify desktop.html about terminal activity
                    if (window.parent) {
                        window.parent.postMessage({ type: 'terminalActivity' }, '*');
                    }
                } else {
                    return App.ui.showNotification(`Cannot run .${ext} files directly.`, 'error');
                }
            },
            updateRunButtonState(path) {
                if (!App.dom.run_btn) { // Add null check for run_btn
                    console.warn("Run button element not found, cannot update its state.");
                    return;
                }
                if (!path) { 
                    App.dom.run_btn.disabled = true; 
                    return; 
                }
                const ext = path.split('.').pop();
                // Only enable if language is runnable AND its environment is ready
                const isPythonReady = ext === 'py' && App.terminal.state.pyodideReady;
                const isLuaReady = ext === 'lua' && App.terminal.state.luaReady;
                const isJsOrHtml = ['js', 'html'].includes(ext); // JS and HTML don't need external runtimes, always ready

                App.dom.run_btn.disabled = !(isPythonReady || isLuaReady || isJsOrHtml);
            }
        },
        
        terminal: { // Internal Terminal Module
            dom: { output: null, loadingOverlay: null, loadingText: null }, 
            state: {
                pyodideLoading: false,
                pyodideReady: false,
                luaLoading: false,
                luaReady: false,
            },
            async init() {
                // Ensure DOM elements are cached and available before use
                this.dom.output = App.dom.terminal_output_log;
                this.dom.loadingOverlay = App.dom.terminal_loading_overlay;
                this.dom.loadingText = App.dom.terminal_loading_text;

                if (this.dom.output) { // Check if output element is available before clearing
                    this.clear();
                } else {
                    console.error("Terminal output element not found, cannot initialize terminal display.");
                    // Fallback or disable terminal features if core elements are missing
                    this.log("Error: Terminal display is unavailable. Please check HTML structure.", "error"); 
                }

                if (this.dom.loadingOverlay && this.dom.loadingText) { // Check if loading overlay elements are available
                    this.dom.loadingOverlay.classList.remove('hidden');
                    this.dom.loadingText.textContent = 'Loading Python environment...';
                } else {
                    console.warn("Terminal loading overlay elements not found. Loading status may not be displayed.");
                }

                if (!this.state.pyodideLoading && !this.state.pyodideReady) {
                    this.state.pyodideLoading = true;
                    try {
                        App.state.pyodide = await loadPyodide();
                        App.state.pyodide.setStdout({ batched: (str) => this.log(str) });
                        App.state.pyodide.setStderr({ batched: (str) => this.log(str, 'error') });
                        this.state.pyodideReady = true;
                        this.log('Python environment ready.', 'info');
                    } catch (error) {
                        this.log(`Failed to load Python environment: ${error}`, 'error');
                        console.error("Python environment load error:", error); // Detailed console error
                    } finally {
                        this.state.pyodideLoading = false;
                    }
                }

                if (this.dom.loadingText) { // Check before updating text
                    this.dom.loadingText.textContent = 'Loading Lua environment...';
                }

                if (!this.state.luaLoading && !this.state.luaReady) {
                    this.state.luaLoading = true;
                    try {
                        App.state.fengari = window.fengari;
                        if (App.state.fengari) {
                            this.state.luaReady = true;
                            this.log('Lua environment ready.', 'info');
                        } else {
                            throw new Error("Fengari (Lua) library not found. Make sure it's loaded.");
                        }
                    } catch (error) {
                        this.log(`Failed to load Lua environment: ${error}`, 'error');
                        console.error("Lua environment load error:", error); // Detailed console error
                    } finally {
                        this.state.luaLoading = false;
                    }
                }

                if (this.dom.loadingOverlay) { // Check before hiding overlay
                    this.dom.loadingOverlay.classList.add('hidden');
                }
                App.files.updateRunButtonState(App.state.activePaths[App.state.activePane]); 
            },
            log(msg, level = 'log') {
                if (!this.dom.output) { // Ensure output element is defined before appending
                    console.error("Terminal output element is not defined, cannot log message:", msg);
                    return;
                }
                const line = document.createElement('div');
                line.className = 'terminal-output-line';
                if (level === 'error') line.classList.add('terminal-output-error');
                if (level === 'warning') line.classList.add('terminal-output-warning');
                if (level === 'info') line.classList.add('terminal-output-info');
                if (level === 'prompt') line.classList.add('terminal-output-prompt');

                line.innerHTML = String(msg)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;")
                    .replace(/\n/g, '<br>'); 

                this.dom.output.appendChild(line);
                this.dom.output.scrollTop = this.dom.output.scrollHeight; 
            },
            clear() {
                if (this.dom.output) { // Ensure output element is defined before clearing
                    this.dom.output.innerHTML = ''; 
                    this.log('Index-Space IDE Terminal.', 'info');
                    this.log('Type your commands here or run scripts from the editor.', 'info');
                } else {
                    console.warn("Attempted to clear terminal but output element is not defined.");
                }
            },

            async runScriptContent(language, content, path = 'memory') {
                this.log(`\n$ Running ${language} script (${path})...`, 'prompt');
                try {
                    switch(language) {
                        case 'javascript':
                            const originalConsoleLog = console.log;
                            const originalConsoleError = console.error;
                            const capturedLogs = [];
                            const capturedErrors = [];

                            console.log = (...args) => capturedLogs.push(args.map(a => String(a)).join(' '));
                            console.error = (...args) => capturedErrors.push(args.map(a => String(a)).join(' '));

                            try {
                                new Function(content)(); 
                            } catch (e) {
                                capturedErrors.push(`Runtime Error: ${e.stack || e.message}`);
                            } finally {
                                console.log = originalConsoleLog;
                                console.error = originalConsoleError;
                            }

                            if (capturedLogs.length > 0) this.log(capturedLogs.join('\n'));
                            if (capturedErrors.length > 0) this.log(capturedErrors.join('\n'), 'error');
                            break;
                        case 'python':
                            if (this.state.pyodideReady && App.state.pyodide) {
                                await App.state.pyodide.runPythonAsync(content);
                            } else {
                                this.log('Python environment not ready or not loaded.', 'error');
                            }
                            break;
                        case 'lua':
                            if (this.state.luaReady && App.state.fengari) {
                                const fengari = App.state.fengari;
                                const L = fengari.lauxlib.luaL_newstate();
                                fengari.lualib.luaL_openlibs(L);

                                const capturedLuaOutput = [];
                                fengari.lua.lua_pushcfunction(L, () => {
                                    const nargs = fengari.lua.lua_gettop(L);
                                    let s = "";
                                    for (let i = 1; i <= nargs; i++) {
                                        s += fengari.lua.lua_tojsstring(L, i);
                                        if (i < nargs) s += "\t";
                                    }
                                    capturedLuaOutput.push(s);
                                    return 0;
                                });
                                fengari.lua.lua_setglobal(L, "print");

                                const status = fengari.lualib.luaL_dostring(L, fengari.to_luastring(content));
                                if (status !== 0) {
                                    this.log(fengari.lua.lua_tojsstring(L, -1), 'error');
                                }
                                if (capturedLuaOutput.length > 0) this.log(capturedLuaOutput.join('\n'));
                            } else {
                                this.log('Lua environment not ready or not loaded.', 'error');
                            }
                            break;
                        case 'html': 
                            App.ui.showNotification("HTML files are displayed in the Preview panel.", "info");
                            App.ui.switchBottomPanel('preview');
                            break;
                        default:
                            this.log(`No runtime available for ${language} scripts.`, 'error');
                    }
                } catch (e) {
                    this.log(`Execution Error for ${language}: ${e.stack || e.message}`, 'error');
                    console.error(`Full error for ${language} execution:`, e);
                } finally {
                    this.log(`--- End of ${language} execution ---`, 'info');
                    if (this.dom.output) { // Ensure output element exists before scrolling
                        this.dom.output.scrollTop = this.dom.output.scrollHeight;
                    }
                }
            }
        },
        
        linter: {
            lintFile(path, content) {
                const ext = path.split('.').pop();
                const problems = [];
                const lines = content.split('\n');

                lines.forEach((line, i) => {
                    if (ext === 'js' && /var\s/.test(line)) {
                        problems.push({ row: i, column: 0, text: 'Consider using `let` or `const` instead of `var`.', type: 'warning' });
                    }
                    if (ext === 'py' && /print\s/.test(line) && !/print\(/.test(line) && !line.trim().startsWith('#')) {
                        problems.push({ row: i, column: 0, text: 'Python 3 requires `print(...)` syntax.', type: 'error' });
                    }
                    // Basic HTML tag check for unclosed tags (very simple, not comprehensive)
                    if (ext === 'html') {
                        const openTags = [];
                        const matches = line.match(/<(\/?)([a-z][a-z0-9]*)\b[^>]*>/ig);
                        if (matches) {
                            matches.forEach(match => {
                                const isClosing = match.startsWith('</');
                                const tagName = match.match(/<(\/?)(\w+)/i)?.[2]?.toLowerCase();
                                if (tagName) {
                                    if (isClosing) {
                                        if (openTags.length > 0 && openTags[openTags.length - 1] === tagName) {
                                            openTags.pop();
                                        } else {
                                            problems.push({ row: i, column: line.indexOf(match), text: `Unmatched closing tag '</${tagName}>'.`, type: 'error' });
                                        }
                                    } else {
                                        // Self-closing tags in HTML (e.g., <img />, <br />) can be complex.
                                        // For simplicity, this linter only flags unclosed pairs.
                                        // A more robust HTML linter would need a proper HTML parser.
                                        if (!match.endsWith('/>')) { // rudimentary check for non-self-closing
                                            openTags.push(tagName);
                                        }
                                    }
                                }
                            });
                        }
                        // After processing a line, check if any unclosed tags remain for that line (might be false positive for multiline tags)
                        // A more precise linter would check after parsing the whole document.
                        // For now, let's keep the simple line-by-line checks as per original.
                        // Removed the original problematic HTML linting logic: `if (ext === 'html' && /<\/?([a-z][a-z0-9]*)\b[^>]*>/i.test(line) && !/<(\w+)[^>]*>.*<\/\1>/.test(line))`
                        // This was too broad and could generate many false positives.
                    }
                });
                // Final check for unclosed HTML tags after all lines (simplified; a proper linter would be more complex)
                let tempOpenTags = [];
                let lineNumMap = new Map(); // To track where a tag was opened
                let charCount = 0; // To track character index for column

                content.split('\n').forEach((line, i) => {
                    // Reset character count for each line to get column accurately
                    charCount = 0; 
                    const matches = [...line.matchAll(/<(\/?)([a-z][a-z0-9]*)\b[^>]*>/ig)]; // Use matchAll for index
                    matches.forEach(match => {
                        const isClosing = match[1] === '/';
                        const tagName = match[2]?.toLowerCase();
                        const col = match.index; // Column is directly from match.index

                        if (tagName) {
                            if (isClosing) {
                                const openTagIndex = tempOpenTags.lastIndexOf(tagName);
                                if (openTagIndex !== -1) {
                                    tempOpenTags.splice(openTagIndex, 1);
                                } else {
                                    problems.push({ row: i, column: col, text: `Unmatched closing tag '</${tagName}>'.`, type: 'error' });
                                }
                            } else {
                                if (!match[0].endsWith('/>') && !['br', 'img', 'input', 'link', 'meta', 'hr', 'source', 'area', 'base', 'col', 'embed', 'keygen', 'param', 'track', 'wbr'].includes(tagName)) { // Self-closing exceptions
                                    tempOpenTags.push(tagName);
                                    lineNumMap.set(tagName, { row: i, column: col });
                                }
                            }
                        }
                    });
                });

                // Add problems for any remaining unclosed tags at the end of the document
                tempOpenTags.forEach(tagName => {
                    const originalPos = lineNumMap.get(tagName);
                    problems.push({ row: originalPos.row, column: originalPos.column, text: `Unclosed tag '<${tagName}>'.`, type: 'error' });
                });


                App.state.lintResults[path] = problems;
                this.setAnnotationsForPath(path);
                this.renderProblemsPanel();
            },
            setAnnotationsForPath(path) {
                Object.keys(App.state.editors).forEach(paneId => {
                    if (App.state.activePaths[paneId] === path) {
                        const session = App.state.editors[paneId]?.getSession();
                        if (session) this.setAnnotations(session, path);
                    }
                });
            },
            setAnnotations(session, path) {
                   const problems = App.state.lintResults[path] || [];
                   session.setAnnotations(problems);
            },
            renderProblemsPanel() {
                const container = App.dom.panel_problems;
                if (!container) {
                    console.error("Problems panel container not found, cannot render problems.");
                    return;
                }
                container.innerHTML = '';
                let totalProblems = 0;
                
                Object.entries(App.state.lintResults).forEach(([path, problems]) => {
                    if (problems.length > 0) {
                        const fileHeader = document.createElement('div');
                        fileHeader.className = 'p-1 font-bold text-[var(--ide-text-primary)] border-b border-[var(--ide-border-primary)]'; 
                        fileHeader.textContent = path;
                        container.appendChild(fileHeader);
                        
                        problems.forEach(p => {
                            const item = document.createElement('div');
                            item.className = 'problem-item p-1 pl-3 ml-2 text-sm cursor-pointer hover:bg-[var(--ide-bg-hover)]';
                            const icon = p.type === 'error' ? '✖' : '⚠';
                            item.innerHTML = `<span class="text-[var(--ide-text-secondary)]">${icon} Ln ${p.row + 1}:</span> ${p.text}`;
                            item.style.color = p.type === 'error' ? 'var(--ide-error-color)' : 'var(--ide-warning-color)';
                            item.onclick = () => {
                                App.files.open(path); setTimeout(() => App.editor.getActiveEditor().gotoLine(p.row + 1, 0, true), 100);
                                App.ui.switchBottomPanel('problems'); 
                            };
                            container.appendChild(item);
                            totalProblems++;
                        });
                    }
                });
                if (App.dom.problems_count) { // Check before updating textContent
                    App.dom.problems_count.textContent = totalProblems;
                }
            }
        },
        
        search: {
            init() {
                if (App.dom.search_input) { // Add null check for search_input
                    App.dom.search_input.addEventListener('keydown', e => { if (e.key === 'Enter') this.performSearch(); });
                } else {
                    console.warn("Search input element not found, search functionality may be limited.");
                }
            },
            async performSearch() {
                const query = App.dom.search_input?.value || ''; // Add nullish coalescing
                if (query.length < 2) {
                    if (App.dom.search_results) {
                        App.dom.search_results.innerHTML = '';
                    }
                    return;
                }
                const resultsContainer = App.dom.search_results;
                if (!resultsContainer) {
                    console.error("Search results container not found, cannot perform search.");
                    return;
                }
                resultsContainer.innerHTML = '';
                
                const rootNode = await App.fs.getNodeByPath('/');
                const allFilePaths = await App.fs.getAllFilePaths(rootNode);

                const searchRegex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

                for (const path of allFilePaths) {
                    let content;
                    try {
                        const node = await App.fs.getNodeByPath(path);
                        if (!node || node.type !== 'file' || !(node.mimeType && node.mimeType.startsWith('text/'))) {
                            continue; 
                        }
                        content = await App.fs.read(node.id, 'string');
                    } catch (e) {
                        console.warn(`Could not read file for search: ${path}`, e);
                        continue;
                    }
                    
                    const lines = content.split('\n');
                    const fileResults = [];
                    lines.forEach((line, i) => {
                        if (line.toLowerCase().includes(query.toLowerCase())) {
                            fileResults.push({ lineNum: i + 1, lineContent: line });
                        }
                    });

                    if (fileResults.length > 0) {
                        const fileDiv = document.createElement('div');
                        fileDiv.className = 'search-result-file text-[var(--ide-text-secondary)] font-bold p-1 border-b border-[var(--ide-border-primary)]';
                        fileDiv.textContent = path;
                        resultsContainer.appendChild(fileDiv);

                        fileResults.forEach(res => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'search-result-item p-1 pl-3 ml-2 text-sm cursor-pointer hover:bg-[var(--ide-bg-hover)]';
                            itemDiv.innerHTML = `<span class="text-[var(--ide-text-inactive)]">${res.lineNum}: </span>` + 
                                                 res.lineContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')
                                                 .replace(searchRegex, match => `<span style="background-color: var(--ide-accent-primary); color: var(--ide-bg-primary);">${match}</span>`); 

                            itemDiv.onclick = () => {
                                App.files.open(path);
                                setTimeout(() => App.editor.getActiveEditor()?.gotoLine(res.lineNum, 0, true), 100); // Add null check
                                App.ui.switchSidebarView('explorer'); 
                            };
                            resultsContainer.appendChild(itemDiv);
                        });
                    }
                }
            }
        },

        preview: {
            update(path, content) {
                if (!App.dom.preview_frame) {
                    console.warn("Preview frame element not found, cannot update preview.");
                    return;
                }
                if (path && path.endsWith('.html') && App.state.activePaths[App.state.activePane] === path) {
                    const blob = new Blob([content], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    App.dom.preview_frame.src = url;
                    App.dom.preview_frame.onload = () => URL.revokeObjectURL(url); 
                } else if (App.state.activeBottomPanel === 'preview') {
                    App.dom.preview_frame.src = 'about:blank';
                }
            }
        },

        snippets: {
            init() {
                const saved = localStorage.getItem('indexspace_ide_snippets_v1');
                App.state.userSnippets = saved ? JSON.parse(saved) : [{name: "log", code: "console.log($1);"},{name: "html-base", code: "<!DOCTYPE html>\\n<html>\\n<head>\\n  <title>$1</title>\\n</head>\\n<body>\\n\\n</body>\\n</html>"}];
                this.registerSnippets();
            },
            get() { return App.state.userSnippets; },
            save(snippetsText) {
                try {
                    const parsed = JSON.parse(snippetsText);
                    App.state.userSnippets = parsed;
                    localStorage.setItem('indexspace_ide_snippets_v1', JSON.stringify(parsed));
                    this.registerSnippets();
                    App.ui.showNotification('Snippets saved and loaded.', 'success');
                } catch(e) {
                    App.ui.showNotification('Invalid JSON format for snippets.', 'error');
                    App.terminal.log(`Snippet Error: ${e.message}`, 'error');
                }
            },
            registerSnippets() {
                const snippetManager = ace.require("ace/snippets").snippetManager;
                const snippetText = App.state.userSnippets.map(s => `snippet ${s.name}\n\t${s.code.replace(/\n/g, '\n\t')}`).join('\n');
                ['javascript', 'python', 'lua', 'html'].forEach(mode => { 
                    const snippets = snippetManager.parseSnippetFile(snippetText);
                    snippetManager.register(snippets, mode);
                });
            }
        },

        formatter: {
            formatCode(editor) {
                if (!editor) editor = App.editor.getActiveEditor();
                const path = App.state.activePaths[App.state.activePane];
                if (!path || !editor) return; // Ensure editor exists before proceeding

                const ext = path.split('.').pop();
                const parserMap = { 'js': 'babel', 'py': 'python', 'html': 'html', 'css': 'css' }; 
                const parser = parserMap[ext];

                if (!parser || !window.prettier || !window.prettierPlugins) {
                    return App.ui.showNotification(`Formatting not available for .${ext} files (Prettier not loaded or parser missing).`, 'error');
                }

                try {
                    const unformatted = editor.getValue();
                    const plugins = { 
                        'babel': prettierPlugins.babel, 
                        'python': prettierPlugins.python,
                        'html': prettierPlugins.html, 
                        'css': prettierPlugins.postcss 
                    };
                    const formatted = prettier.format(unformatted, {
                        parser: parser,
                        plugins: [plugins[parser]],
                        semi: true,
                        singleQuote: true,
                        printWidth: 80,
                        tabWidth: 4,    
                        useTabs: false,
                        htmlWhitespaceSensitivity: 'css',
                    });
                    const pos = editor.getCursorPosition();
                    editor.setValue(formatted, 1);
                    editor.moveCursorTo(pos.row, pos.column);
                    App.ui.showNotification('Code formatted.', 'success');
                } catch (e) {
                    App.ui.showNotification('Failed to format code.', 'error');
                    App.terminal.log(`Formatter Error: ${e.message}`, 'error');
                }
            }
        },
        
        events: {
            init() {
                // Add null checks for DOM elements before attaching event listeners
                App.dom.activity_bar?.addEventListener('click', e => { const view = e.target.closest('.activity-bar-icon')?.dataset.view; if (view) App.ui.switchSidebarView(view); });
                App.dom.bottom_panel?.querySelector('.tabs')?.addEventListener('click', e => { const panel = e.target.closest('.bottom-panel-tab')?.dataset.panel; if (panel) App.ui.switchBottomPanel(panel); });
                
                App.dom.new_untitled_file_global?.onclick = () => this.showNewFileModal();
                App.dom.welcome_new_file_btn?.onclick = () => this.showNewFileModal(); 
                App.dom.new_folder_global?.onclick = () => this.showNewItemModal('folder');
                
                App.dom.file_explorer?.oncontextmenu = (e) => this.showContextMenu(e);
                
                App.dom.cmd_palette_btn?.onclick = () => this.showCommandPalette();
                App.dom.beta_palette_btn?.onclick = () => this.showBetaFeaturesPalette();
                App.dom.run_btn?.onclick = () => App.files.runActive();
                App.dom.split_view_btn?.onclick = () => App.layout.toggleSplitView();
                App.dom.save_snippets_btn?.onclick = () => App.snippets.save(App.state.snippetsEditor?.getValue() || ''); // Add null check for snippetsEditor

                App.dom.explorer_search?.oninput = () => App.ui.renderExplorer();
                App.dom.search_input?.oninput = () => App.search.performSearch(); 
                
                App.dom.setting_theme?.onchange = (e) => App.settings.update('theme', e.target.value);
                App.dom.setting_fontsize?.oninput = (e) => App.settings.update('fontSize', parseInt(e.target.value));
                App.dom.setting_keymap?.onchange = (e) => App.settings.update('keymap', e.target.value);
                App.dom.setting_linenumbers?.onchange = (e) => App.settings.update('showLineNumbers', e.target.checked);
                App.dom.setting_minimap?.onchange = (e) => App.settings.update('showMinimap', e.target.checked);
                App.dom.setting_wordwrap?.onchange = (e) => App.settings.update('wordWrap', e.target.checked);
                App.dom.setting_autosave?.onchange = (e) => App.settings.update('autoSave', e.target.checked);
                
                App.dom.file_importer?.onchange = (e) => this.readAndCreateFiles(e.target.files);
                App.dom.view_explorer?.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }); // Changed from explorerEl to App.dom.view_explorer
                App.dom.view_explorer?.addEventListener('drop', e => { e.preventDefault(); this.handleFileDrop(e); }); // Changed from explorerEl to App.dom.view_explorer
                
                document.addEventListener('click', (e) => { 
                    if (App.dom.context_menu && !e.target.closest('#context-menu')) { // Add null check
                        App.dom.context_menu.classList.add('hidden'); 
                    }
                });
                document.addEventListener('keydown', (e) => {
                    const activeEl = document.activeElement;
                    const isInputFocused = activeEl instanceof HTMLInputElement || activeEl instanceof HTMLTextAreaElement || activeEl?.classList.contains('renaming'); // Add null check
                    if (isInputFocused && !['Enter', 'Escape'].includes(e.key)) {
                        return;
                    }

                    const isCtrlOrCmd = e.ctrlKey || e.metaKey; 

                    switch (e.key) {
                        case 'Delete':
                        case 'Backspace': 
                            const selectedItems = App.dom.file_explorer?.querySelectorAll('.file-item.selected'); // Add null check
                            if (selectedItems?.length > 0) { // Add null check
                                e.preventDefault(); 
                                this.showDeleteConfirmModal([...selectedItems].map(el => el.dataset.path));
                            }
                            break;
                        case 'F2':
                            e.preventDefault();
                            const selectedExplorerItem = App.dom.file_explorer?.querySelector('.file-item.selected'); // Add null check
                            if (selectedExplorerItem) {
                                this.showRenameModal(selectedExplorerItem.dataset.path);
                            }
                            break;
                        case 's':
                            if (isCtrlOrCmd) { e.preventDefault(); App.files.save(); }
                            break;
                        case 'j':
                            if (isCtrlOrCmd) { e.preventDefault(); App.ui.toggleBottomPanel(); }
                            break;
                        case 'e':
                            if (isCtrlOrCmd && e.shiftKey) { e.preventDefault(); App.ui.switchSidebarView('explorer'); }
                            break;
                        case 'f':
                            if (isCtrlOrCmd && e.shiftKey) { e.preventDefault(); App.ui.switchSidebarView('search'); }
                            break;
                        case 'n':
                            if (isCtrlOrCmd) {
                                e.preventDefault();
                                if (e.shiftKey) { this.showNewFileModal(); } 
                                else { this.showNewItemModal('folder', '/'); } 
                            }
                            break;
                        case 'p':
                            if (isCtrlOrCmd && e.shiftKey) { e.preventDefault(); this.showCommandPalette(); }
                            break;
                        case 'Escape': 
                            App.ui.hideModal(); 
                            App.dom.context_menu?.classList.add('hidden'); // Add null check
                            App.editor.getActiveEditor()?.focus(); 
                            break;
                    }
                });

                App.dom.file_explorer?.addEventListener('click', e => { // Add null check
                    const itemEl = e.target.closest('.file-item');
                    App.dom.file_explorer.querySelectorAll('.file-item.selected').forEach(el => el.classList.remove('selected'));
                    if (itemEl) itemEl.classList.add('selected');
                });
            },
            showNewFileModal() {
                const content = document.createElement('div'); content.className = 'modal-base p-4';
                content.innerHTML = `<h3 class="text-lg font-bold mb-4">Create New File</h3><div class="grid grid-cols-2 gap-2"></div>`;
                const grid = content.querySelector('.grid');
                const languages = { 'Python': 'py', 'Lua': 'lua', 'HTML': 'html', 'JavaScript': 'js' }; 
                Object.entries(languages).forEach(([name, ext]) => {
                    const btn = document.createElement('button');
                    btn.className = 'p-4 rounded hover:bg-[var(--ide-bg-hover)] bg-[var(--ide-bg-primary)]';
                    btn.textContent = name;
                    btn.onclick = () => {
                        App.files.openUntitled(ext);
                        App.ui.hideModal();
                    };
                    grid.appendChild(btn);
                });
                App.ui.showModal(content);
            },
            showNewItemModal(type, basePath = '/') { 
                const content = document.createElement('div'); content.className = 'modal-base p-4';
                content.innerHTML = `<h3 class="text-lg font-bold mb-4">New ${type === 'folder' ? 'Folder' : 'File'}</h3><input type="text" id="modal-input-name" class="modal-input" placeholder="Enter name...">`;
                App.ui.showModal(content);
                const input = document.getElementById('modal-input-name'); 
                if (input) { // Check input before focusing
                    input.focus();
                    input.onkeydown = async (e) => { 
                        if (e.key === 'Enter' && input.value) { 
                            const name = input.value.trim();
                            if (!name) { App.ui.showNotification('Name cannot be empty.', 'error'); return; }
                            const path = `${basePath === '/' ? '' : basePath}/${name}`; 
                            try {
                                if (type === 'folder') await App.fs.mkdir(path);
                                else await App.fs.write(path, ''); // Empty content for new file
                                App.ui.hideModal(); 
                                App.ui.renderExplorer(); 
                            } catch (error) {
                                App.ui.showNotification(`Error creating ${type}: ${error.message}`, 'error');
                            }
                        } else if (e.key === 'Escape') App.ui.hideModal(); 
                    };
                } else {
                    console.error("Modal input element (modal-input-name) not found for new item modal.");
                }
            },
            // showContextMenu 함수는 이전 내용에서 이미 전체적으로 제공되었으므로, 여기서는 함수 정의만 남깁니다.
            // 전체 함수 내용은 이전 답변의 'editor.html' 최종 버전을 참고하시거나,
            // 아니면 이 다음부터 작성되는 전체 코드에 포함될 것입니다.
            showContextMenu(e) {
                e.preventDefault(); e.stopPropagation();
                const target = e.target.closest('.file-item');
                const path = target?.dataset.path;
                const nodeId = target?.dataset.id;
                
                let items = [];

                if (nodeId) { // Context menu for a specific file/folder
                    // VFS.getNode는 비동기 함수이므로, 여기서는 데이터셋에서 직접 접근할 수 있는 정보만 사용합니다.
                    // 더 복잡한 노드 정보가 필요하면 async/await로 getNode 호출이 필요합니다.
                    // 편의를 위해 일단 type은 DOM에서 가져올 수 있다고 가정합니다 (예: data-type 속성 추가).
                    // 또는 컨텍스트 메뉴를 열 때 getNode를 호출하여 메뉴 항목의 disabled 상태를 동적으로 결정할 수 있습니다.
                    // IMPORTANT: The getCurrentNodeFromExplorer helper below is a dummy. For robust production, 
                    // make this showContextMenu async and fetch the actual node: `const nodeFromExplorer = await App.fs.getNode(nodeId);`
                    const nodeFromExplorer = App.ui.getCurrentNodeFromExplorer(nodeId); 
                    const isFile = nodeFromExplorer?.type === 'file';
                    const isFolder = nodeFromExplorer?.type === 'folder';

                    if (isFile) {
                        items.push({ label: 'Open', action: () => App.files.open(path) });
                        items.push({ label: 'Run File', action: () => App.files.runActive() });
                    }
                    items.push({ label: 'Rename', action: () => this.showRenameModal(path) });
                    items.push({ label: 'Delete', action: () => this.showDeleteConfirmModal([path]) });
                    
                    if (isFolder) {
                        items.push(null); // Divider
                        items.push({ label: 'New File', action: () => this.showNewFileModal(path) });
                        items.push({ label: 'New Folder', action: () => this.showNewItemModal('folder', path) });
                    }
                } else { // Context menu for empty space in explorer (assumed to be root or current view's base path)
                    // If no specific file/folder clicked, assume context is for the current folder being displayed
                    // For now, hardcode to root for simplicity, but in a real app, you'd get the current explorer path
                    const currentExplorerPath = '/'; // Or from a state variable like App.state.currentExplorerViewPath
                    items.push({ label: 'New File', action: () => this.showNewFileModal(currentExplorerPath) });
                    items.push({ label: 'New Folder', action: () => this.showNewItemModal('folder', currentExplorerPath) });
                    items.push(null); // Divider
                    items.push({ label: 'Refresh Explorer', action: () => App.ui.renderExplorer() });
                }

                const menuEl = App.dom.context_menu;
                if (!menuEl) {
                    console.error("Context menu element not found.");
                    return;
                }
                menuEl.innerHTML = items.map(item => item ? `<div class="context-menu-item px-4 py-2" data-label="${item.label}">${item.label}</div>` : '<div class="context-menu-divider"></div>').join('');
                
                menuEl.onclick = (ev) => { 
                    const actionLabel = ev.target.closest('.context-menu-item')?.dataset.label; // Use closest for safety
                    if(actionLabel) {
                        const actionItem = items.find(i => i && i.label === actionLabel); // Check for null item
                        actionItem?.action(); 
                    }
                    menuEl.classList.add('hidden'); 
                };
                menuEl.style.left = `${e.clientX}px`; menuEl.style.top = `${e.clientY}px`;
                menuEl.classList.remove('hidden');
            },
            showRenameModal(path) {
                const oldName = path.split('/').pop();
                const content = document.createElement('div'); content.className = 'modal-base p-4';
                content.innerHTML = `<h3 class="text-lg font-bold mb-4">Rename</h3><input type="text" id="modal-input-rename" class="modal-input">`;
                App.ui.showModal(content);
                const input = document.getElementById('modal-input-rename'); 
                if (input) { // Check input before focusing
                    input.value = oldName; input.focus(); input.select();
                    input.onkeydown = async (e) => { 
                        if (e.key === 'Enter' && input.value) { 
                            const newName = input.value.trim();
                            if (!newName) { App.ui.showNotification('Name cannot be empty.', 'error'); return; }
                            try {
                                const nodeToRename = await App.fs.getNodeByPath(path);
                                if (nodeToRename) {
                                    await App.fs.rename(nodeToRename.id, newName);
                                    App.ui.hideModal(); 
                                    App.ui.renderExplorer();
                                    // Update open tab if renamed file is open
                                    ['pane1', 'pane2'].forEach(paneId => {
                                        if (App.state.openFiles[paneId].has(path)) {
                                            const fileData = App.state.openFiles[paneId].get(path);
                                            App.state.openFiles[paneId].delete(path);
                                            const newPath = path.substring(0, path.lastIndexOf('/') + 1) + newName;
                                            App.state.openFiles[paneId].set(newPath, fileData);
                                            if (fileData.tabEl) { // Check before accessing tabEl
                                                fileData.tabEl.dataset.path = newPath;
                                                fileData.tabEl.title = newPath;
                                                const tabNameSpan = fileData.tabEl.querySelector('.tab-name');
                                                if (tabNameSpan) {
                                                    tabNameSpan.textContent = newName;
                                                }
                                            }
                                            if (App.state.activePaths[paneId] === path) {
                                                App.state.activePaths[paneId] = newPath;
                                            }
                                        }
                                    });
                                    App.ui.updateStatus(); // Update status bar if needed
                                } else {
                                    App.ui.showNotification(`Rename failed: Original node not found.`, 'error');
                                }
                            } catch (error) {
                                App.ui.showNotification(`Rename failed: ${error.message}`, 'error');
                            }
                        } else if (e.key === 'Escape') App.ui.hideModal(); 
                    };
                } else {
                    console.error("Modal input element (modal-input-rename) not found for rename modal.");
                }
            },
            showDeleteConfirmModal(pathsToDelete) {
                if (!pathsToDelete || pathsToDelete.length === 0) return;
                const itemNames = pathsToDelete.map(p => p.split('/').pop()).join(', ');
                const content = document.createElement('div'); content.className = 'modal-base p-4';
                content.innerHTML = `
                    <h3 class="text-lg font-bold mb-4">Confirm Deletion</h3>
                    <p class="text-[var(--ide-text-secondary)]">Are you sure you want to delete ${pathsToDelete.length} item(s)?</p>
                    <p class="text-[var(--ide-text-primary)] font-mono text-sm">${itemNames}</p>
                    <div class="flex justify-center mt-4">
                        <button id="modal-cancel-btn" class="px-4 py-2 rounded bg-gray-700 hover:bg-gray-600">Cancel</button>
                        <button id="modal-confirm-btn" class="px-4 py-2 rounded bg-[var(--ide-error-color)] hover:opacity-80 ml-2">Delete</button>
                    </div>
                `;
                App.ui.showModal(content);
                document.getElementById('modal-cancel-btn')?.onclick = () => App.ui.hideModal(); // Add null check
                document.getElementById('modal-confirm-btn')?.onclick = async () => { // Add null check
                    for (const path of pathsToDelete) {
                        try {
                            const node = await App.fs.getNodeByPath(path);
                            if (node) {
                                // Ensure any open editors for this file are closed first
                                ['pane1', 'pane2'].forEach(paneId => {
                                    if (App.state.openFiles[paneId].has(path)) {
                                        App.files.close(path, true, paneId); // Force close
                                    }
                                });
                                await App.fs.delete(node.id);
                                App.ui.showNotification(`Deleted '${node.name}'`, 'success');
                            } else {
                                App.ui.showNotification(`Item '${path.split('/').pop()}' not found, skipping delete.`, 'warning');
                            }
                        } catch (error) {
                            App.ui.showNotification(`Failed to delete '${path.split('/').pop()}': ${error.message}`, 'error');
                            console.error('Delete error:', error);
                        }
                    }
                    App.ui.hideModal();
                    App.ui.renderExplorer();
                };
            },
            showSaveAsModal(untitledPath, paneId) {
                const content = document.createElement('div'); content.className = 'modal-base p-4';
                content.innerHTML = `<h3 class="text-lg font-bold mb-4">Save As</h3><input type="text" id="modal-input-save" class="modal-input" placeholder="Enter file path (e.g., my-projects/app.js)">`;
                App.ui.showModal(content);
                const input = document.getElementById('modal-input-save'); 
                if (input) { // Check input before focusing
                    input.focus();
                    input.onkeydown = async (e) => {
                        if (e.key === 'Enter' && input.value) {
                            const newPath = input.value.trim();
                            if (!newPath) { App.ui.showNotification('Path cannot be empty.', 'error'); return; }
                            const data = App.state.openFiles[paneId].get(untitledPath); 
                            if (!data) { 
                                App.ui.hideModal(); 
                                console.error(`No data for untitled file: ${untitledPath}`);
                                return;
                            }
                            try {
                                await App.fs.write(newPath, data.session.getValue());
                                App.files.close(untitledPath, true, paneId);
                                App.files.open(newPath, paneId); 
                                App.ui.hideModal();
                                App.ui.showNotification(`File saved as ${newPath}`, 'success');
                            } catch (error) {
                                App.ui.showNotification(`Save failed: ${error.message}`, 'error');
                                console.error("Save As error:", error);
                            }
                        } else if (e.key === 'Escape') App.ui.hideModal();
                    };
                } else {
                    console.error("Modal input element (modal-input-save) not found for save as modal.");
                }
            },
            async readAndCreateFiles(files) {
                if (!files || files.length === 0) return;
                for(const file of files) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const content = e.target.result;
                        // Determine if it's a text file based on MIME type or extension
                        const isTextFile = file.type.startsWith('text/') || ['js', 'py', 'html', 'css', 'json', 'md', 'txt', 'lua'].some(ext => file.name.endsWith(`.${ext}`));
                        try {
                            // Default upload to root folder ('/')
                            const targetPath = '/'; 
                            // Ensure file.name starts with a slash if it's going into root directly
                            const fullTargetPath = `${targetPath}${file.name.startsWith('/') ? file.name.substring(1) : file.name}`;
                            await App.fs.write(fullTargetPath, isTextFile ? content : new Blob([content], {type: file.type})); // Pass Blob for non-text files
                            App.ui.showNotification(`Uploaded '${file.name}'`, 'success');
                            App.ui.renderExplorer();
                        } catch (error) {
                            App.ui.showNotification(`Failed to upload '${file.name}': ${error.message}`, 'error');
                            console.error("File upload error:", error);
                        }
                    };
                    // Read as text for known text types, otherwise as ArrayBuffer (for Blob)
                    if (file.type.startsWith('text/') || ['js', 'py', 'html', 'css', 'json', 'md', 'txt', 'lua'].some(ext => file.name.endsWith(`.${ext}`))) {
                        reader.readAsText(file);
                    } else {
                        reader.readAsArrayBuffer(file); // For non-text files, read as ArrayBuffer for Blob storage
                    }
                }
            },
            handleFileImport(event) { this.readAndCreateFiles(event.target.files); },
            handleFileDrop(event) { this.readAndCreateFiles(event.dataTransfer.files); },
            async showCommandPalette() { // Changed to async because of App.fs.getNodeByPath
                const content = document.createElement('div'); content.className = 'modal-base';
                content.innerHTML = `<input type="text" id="cmd-input" class="modal-input m-2" placeholder="Search files and commands..."><div id="cmd-list" class="overflow-y-auto max-h-[50vh]"></div>`;
                App.ui.showModal(content);
                const input = document.getElementById('cmd-input'); 
                const list = document.getElementById('cmd-list');

                if (!input || !list) {
                    console.error("Command palette input or list element not found.");
                    App.ui.hideModal();
                    return;
                }

                const commands = [
                    { label: 'File: New File...', action: () => this.showNewFileModal() },
                    { label: 'File: Save Active File', action: () => App.files.save() },
                    { label: 'Edit: Format Document', action: () => App.formatter.formatCode() },
                    { label: 'View: Toggle Split View', action: () => App.layout.toggleSplitView() },
                    { label: 'Run: Run Active File', action: () => App.files.runActive() },
                    { label: 'View: Toggle Terminal', action: () => App.ui.toggleBottomPanel() },
                    { label: 'Explorer: New Folder', action: () => this.showNewItemModal('folder') },
                    { label: 'Editor: Increase Font Size', action: () => App.settings.update('fontSize', App.state.settings.fontSize + 1) },
                    { label: 'Editor: Decrease Font Size', action: () => App.settings.update('fontSize', App.state.settings.fontSize - 1) },
                ];
                
                const rootNode = await App.fs.getNodeByPath('/'); // Await this call
                let allFiles = [];
                if (rootNode) {
                    const filePaths = await App.fs.getAllFilePaths(rootNode);
                    allFiles = filePaths.map(p => ({ label: `📄 ${p}`, action: () => App.files.open(p) }));
                } else {
                    console.warn("Root node not found for command palette file listing.");
                }
                
                const allItems = [...commands, ...allFiles];
                this.setupPalette(input, list, allItems);
            },
            showBetaFeaturesPalette() {
                const content = document.createElement('div'); content.className = 'modal-base';
                content.innerHTML = `<input type="text" id="cmd-input" class="modal-input m-2" placeholder="Search Beta Features..."><div id="cmd-list" class="overflow-y-auto max-h-[50vh]"></div>`;
                App.ui.showModal(content);
                const input = document.getElementById('cmd-input'); 
                const list = document.getElementById('cmd-list');

                if (!input || !list) {
                    console.error("Beta palette input or list element not found.");
                    App.ui.hideModal();
                    return;
                }

                const commands = [
                    { "label": "Beta: UI: Increase Font Size", "action": () => App.settings.update('fontSize', App.state.settings.fontSize + 1) },
                    { "label": "Beta: UI: Decrease Font Size", "action": () => App.settings.update('fontSize', App.state.settings.fontSize - 1) },
                    { "label": "Beta: Workspace: Clear All Data (Danger!)", "action": () => {
                        if (confirm("Are you sure you want to delete ALL IDE data (files, settings, snippets)? This cannot be undone.")) {
                            indexedDB.deleteDatabase(App.fs.DB_NAME);
                            localStorage.clear(); // Clear all local storage settings etc.
                            App.ui.showNotification("All IDE data cleared. Please refresh the page.", "error");
                            window.location.reload();
                        }
                    }},
                ];
                this.setupPalette(input, list, commands);
            },
            setupPalette(input, list, items) {
                let activeItemIndex = -1; // Track active item for keyboard navigation

                const renderList = (query='') => {
                    const filtered = items.filter(c => c.label.toLowerCase().includes(query.toLowerCase()));
                    list.innerHTML = filtered.map((c, index) => 
                        `<div class="command-palette-item p-2 cursor-pointer hover:bg-[var(--ide-bg-hover)] ${index === activeItemIndex ? 'active' : ''}" data-label="${c.label}">${c.label}</div>`
                    ).join('');
                    if (filtered.length > 0 && activeItemIndex === -1) {
                        activeItemIndex = 0; // Set first item as active by default
                        list.children[0]?.classList.add('active');
                    }
                };
                const executeAction = (label) => {
                    items.find(c=>c.label===label)?.action(); 
                    App.ui.hideModal();
                };
                list.onclick = (e) => { 
                    const label = e.target.closest('.command-palette-item')?.dataset.label; 
                    if(label) executeAction(label); 
                };
                input.oninput = () => {
                    activeItemIndex = -1; // Reset active item on input change
                    renderList(input.value);
                };
                input.onkeydown = (e) => {
                    const currentItems = Array.from(list.children);
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        if (activeItemIndex < currentItems.length - 1) {
                            if (activeItemIndex !== -1) currentItems[activeItemIndex].classList.remove('active');
                            activeItemIndex++;
                            currentItems[activeItemIndex].classList.add('active');
                            currentItems[activeItemIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (activeItemIndex > 0) {
                            currentItems[activeItemIndex].classList.remove('active');
                            activeItemIndex--;
                            currentItems[activeItemIndex].classList.add('active');
                            currentItems[activeItemIndex].scrollIntoView({ block: 'nearest' });
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (activeItemIndex !== -1 && currentItems[activeItemIndex]) {
                            executeAction(currentItems[activeItemIndex].dataset.label);
                        } else if (currentItems.length > 0) { // If nothing active, but items exist, execute first
                             executeAction(currentItems[0].dataset.label);
                        }
                    } else if (e.key === 'Escape') {
                        App.ui.hideModal();
                    }
                }
                input.focus(); renderList('');
            }
        }
    };

    App.init();
    </script>
</body>
</html>
