<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete File Explorer v7.2 - Index-Space</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-background: #0D1117;
            --color-text-primary: #E6EDF3;
            --color-text-secondary: #8B949E;
            --color-surface-1: #161B22;
            --color-surface-2: #0D1117;
            --color-border: #30363D;
            --color-accent: #58A6FF;
            --color-selection-bg: rgba(88, 166, 255, 0.2);
            --color-modal-bg: rgba(13, 17, 23, 0.9);
            --color-danger: #DA3633;
            --color-success: #238636;
            --color-warning: #D29922;
            --font-primary: 'Inter', 'Segoe UI', 'Helvetica Neue', 'Arial', sans-serif;
            --font-mono: 'JetBrains Mono', 'Consolas', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%; height: 100%; overflow: hidden;
            background-color: var(--color-background); color: var(--color-text-primary);
            font-family: var(--font-primary); user-select: none;
        }

        .app-container {
            display: flex; flex-direction: column; width: 100%; height: 100%;
            background-color: var(--color-surface-1);
        }

        /* Toolbar Styles */
        .explorer-toolbar {
            display: flex; align-items: center; padding: 8px;
            border-bottom: 1px solid var(--color-border); gap: 8px;
            background: linear-gradient(135deg, var(--color-surface-2), #1a1f26);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .nav-btn {
            background: rgba(255,255,255,0.05); border: 1px solid var(--color-border);
            color: var(--color-text-secondary); border-radius: 8px;
            width: 32px; height: 32px; cursor: pointer; font-size: 1.1rem;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background: var(--color-accent); color: white;
            transform: translateY(-1px); box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }

        .nav-btn:disabled {
            color: #444; cursor: not-allowed; opacity: 0.5;
        }

        .path-bar {
            flex-grow: 1; background: rgba(13, 17, 23, 0.8);
            border: 1px solid var(--color-border); border-radius: 8px;
            padding: 8px 12px; font-size: 0.9em; color: var(--color-text-primary);
            font-family: var(--font-mono);
            transition: all 0.2s ease;
        }

        .path-bar:focus {
            outline: none; border-color: var(--color-accent);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        .search-bar, #file-type-filter {
            background: rgba(13, 17, 23, 0.6);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 6px 12px;
            color: var(--color-text-primary);
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        .search-bar { width: 200px; }
        #file-type-filter {
            width: 120px;
            appearance: none; /* Remove default arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%238B949E'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            cursor: pointer;
        }
        .search-bar:focus, #file-type-filter:focus {
            outline: none; border-color: var(--color-accent);
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.2);
        }

        /* Main Content */
        .explorer-body {
            display: flex; flex-grow: 1; height: calc(100% - 57px - 30px);
        }

        .sidebar {
            width: 250px; background: var(--color-surface-2);
            border-right: 1px solid var(--color-border);
            padding: 16px; overflow-y: auto;
        }

        .sidebar h3 {
            color: var(--color-text-secondary);
            font-size: 0.85rem; font-weight: 500;
            margin-bottom: 12px; text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quick-access-item {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 12px; border-radius: 6px; cursor: pointer;
            margin-bottom: 4px; transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .quick-access-item:hover, .quick-access-item.active {
            background: rgba(255,255,255,0.1);
        }

        .explorer-main {
            flex-grow: 1; display: flex; flex-direction: column; overflow: hidden;
        }

        .content-area {
            flex-grow: 1; overflow-y: auto; padding: 16px;
            background: var(--color-background);
        }

        /* View Controls */
        .view-controls {
            display: flex;
            align-items: center;
            margin-left: auto; /* Push to the right */
            gap: 4px;
        }

        .view-control-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
            border-radius: 6px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .view-control-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        .view-control-btn.active {
            background: var(--color-accent);
            color: white;
            border-color: var(--color-accent);
        }


        /* File Items (Common) */
        .file-item {
            padding: 12px; border-radius: 8px;
            border: 2px solid transparent; cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            background: rgba(255,255,255,0.02);
            color: var(--color-text-primary);
        }

        .file-item:hover {
            background: rgba(255,255,255,0.08);
            transform: translateY(-1px);
        }

        .file-item.selected {
            background: var(--color-selection-bg);
            border-color: var(--color-accent);
            box-shadow: 0 4px 16px rgba(88, 166, 255, 0.3);
        }

        .file-item.drag-over {
            border: 2px dashed var(--color-accent) !important;
        }

        .file-item-name {
            font-size: 0.9em; font-weight: 500;
            word-break: break-all;
        }

        .file-item-name.renaming {
            background: white; color: black; outline: none; padding: 2px 4px;
            border-radius: 4px; border: 1px solid var(--color-accent);
            display: block; /* Ensure input takes full width */
            box-sizing: border-box; /* Include padding/border in width */
        }

        .file-item-meta {
            font-size: 0.75em; color: var(--color-text-secondary);
        }


        /* List View Specific Styles */
        .content-area.file-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0; /* Remove padding from content-area if list-header is used */
        }

        .content-area.file-list .file-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px; /* Adjusted padding for list view */
            background: var(--color-surface-1); /* Slightly different background for list items */
            border: none; /* Remove border for list items */
        }
        .content-area.file-list .file-item:hover {
             background: rgba(255,255,255,0.05);
             transform: none;
        }
        .content-area.file-list .file-item.selected {
            background: var(--color-selection-bg);
            border-left: 3px solid var(--color-accent);
            box-shadow: none;
        }

        .content-area.file-list .file-item-icon {
            font-size: 1.5em; /* Smaller icons for list view */
            width: 24px;
            height: 24px;
            display: flex; /* Ensure centering */
            align-items: center;
            justify-content: center;
        }

        .content-area.file-list .file-item-name {
            flex-grow: 1; /* Take up remaining space */
            margin-bottom: 0;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Show ellipsis for overflow */
        }

        .content-area.file-list .file-item-meta {
            width: 100px; /* Fixed width for size/date in list view */
            text-align: right;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .content-area.file-list .file-item-meta.list-col-size { width: 80px; }
        .content-area.file-list .file-item-meta.list-col-date { width: 150px; }


        .list-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--color-border);
            font-size: 0.8em;
            color: var(--color-text-secondary);
            background: var(--color-surface-2);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .list-header-item {
            cursor: pointer;
            padding: 0 4px;
            position: relative;
        }
        .list-header-item:hover {
            color: var(--color-accent);
        }
        .list-header-item.sort-asc:after { content: ' ▲'; }
        .list-header-item.sort-desc:after { content: ' ▼'; }

        .list-col-name { flex-grow: 1; }
        .list-col-size { width: 80px; text-align: right; }
        .list-col-date { width: 150px; text-align: right; }

        /* Grid View Specific Styles */
        .content-area.file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); /* Smaller grid items */
            gap: 16px;
            padding: 16px; /* Reset padding for grid view */
        }

        .content-area.file-grid .file-item {
            flex-direction: column;
            text-align: center;
            padding: 16px 8px;
        }

        .content-area.file-grid .file-item-icon {
            font-size: 2.5em;
            width: 60px;
            height: 60px;
            margin-bottom: 8px;
        }

        .content-area.file-grid .file-item-name {
            margin-bottom: 4px;
            height: 3em; /* Allow 2-3 lines of text */
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .content-area.file-grid .file-item-meta {
            display: block;
        }


        /* Status Bar */
        .explorer-statusbar {
            height: 30px; background: var(--color-surface-2);
            border-top: 1px solid var(--color-border);
            padding: 0 16px; font-size: 0.8rem; color: var(--color-text-secondary);
            display: flex; align-items: center; justify-content: space-between;
        }

        /* Context Menu */
        .context-menu {
            position: fixed; background: #21262d;
            border: 1px solid var(--color-border); border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4); padding: 6px;
            z-index: 10001; opacity: 0; transform: scale(0.95);
            transition: all 0.15s ease-out; pointer-events: none;
            backdrop-filter: blur(8px);
        }

        .context-menu.visible {
            opacity: 1; transform: scale(1); pointer-events: auto;
        }

        .context-menu-item {
            padding: 10px 16px; cursor: pointer; border-radius: 6px;
            white-space: nowrap; display: flex; align-items: center; gap: 10px;
            font-size: 0.85rem; transition: all 0.1s ease;
        }

        .context-menu-item:hover:not(.disabled) {
            background: var(--color-accent); color: white;
        }

        .context-menu-item.disabled {
            color: var(--color-text-secondary); cursor: not-allowed;
            opacity: 0.5;
        }

        .context-menu-divider {
            height: 1px; background: var(--color-border);
            margin: 6px 8px;
        }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--color-modal-bg); backdrop-filter: blur(8px);
            z-index: 20000; display: flex; justify-content: center; align-items: center;
            animation: fadeIn 0.2s ease-out;
        }

        .modal-dialog {
            background: var(--color-surface-1); padding: 2rem; border-radius: 12px;
            border: 1px solid var(--color-border); text-align: center;
            max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;
            box-shadow: 0 16px 64px rgba(0,0,0,0.5);
            animation: slideIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }

        .modal-dialog h3 {
            margin-bottom: 1rem; color: var(--color-text-primary);
        }

        .modal-dialog p {
            margin-bottom: 1.5rem; color: var(--color-text-secondary);
        }

        .modal-dialog button {
            background: var(--color-surface-2); border: 1px solid var(--color-border);
            color: var(--color-text-primary); padding: 10px 20px; border-radius: 6px;
            cursor: pointer; margin: 0 8px; font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .modal-dialog button:hover {
            background: rgba(255,255,255,0.1);
        }

        .modal-dialog .primary-btn {
            background: var(--color-accent); border-color: var(--color-accent);
        }

        .modal-dialog .danger-btn {
            background: var(--color-danger); border-color: var(--color-danger);
        }

        .modal-dialog .success-btn {
            background: var(--color-success); border-color: var(--color-success);
        }

        /* File Viewer Modal Specifics */
        .file-viewer-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-bottom: 1.5rem;
        }

        .file-viewer-content textarea {
            width: 100%;
            flex-grow: 1;
            min-height: 200px; /* Minimum height for text area */
            background: var(--color-surface-2);
            border: 1px solid var(--color-border);
            color: var(--color-text-primary);
            font-family: var(--font-mono);
            padding: 10px;
            border-radius: 6px;
            resize: vertical;
            font-size: 0.9em;
            text-align: left; /* Override parent text-align */
        }

        .file-viewer-content img {
            max-width: 100%;
            max-height: 60vh; /* Limit image height within modal */
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        /* Properties Modal specific styles */
        .properties-content {
            text-align: left;
            width: 100%;
            max-width: 400px; /* Constrain width for properties table */
            margin: 0 auto; /* Center the content */
            padding-bottom: 1.5rem;
        }

        .properties-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .properties-content td {
            padding: 8px 0;
            border-bottom: 1px solid var(--color-border);
        }

        .properties-content td:first-child {
            color: var(--color-text-secondary);
            font-weight: 500;
            padding-right: 20px;
            width: 35%; /* Adjust label width */
        }

        .properties-content td:last-child {
            color: var(--color-text-primary);
            word-break: break-all;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 1.5rem;
        }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-20px) scale(0.95); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }

        /* Drag and Drop */
        .drag-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(88, 166, 255, 0.1); z-index: 9999;
            display: none; align-items: center; justify-content: center;
            border: 3px dashed var(--color-accent);
        }

        .drag-overlay.active { display: flex; }

        .drag-message {
            background: var(--color-surface-1); padding: 2rem;
            border-radius: 12px; border: 2px solid var(--color-accent);
            font-size: 1.2rem; color: var(--color-accent);
        }

        /* Utility */
        .hidden { display: none !important; }

    </style></head><body>
    <main id="app-container" class="app-container"></main>
    <div id="context-menu-container"></div>
    <div id="modal-container"></div>
    <input type="file" id="file-uploader" multiple class="hidden" />
    <a id="file-downloader" class="hidden"></a>
    <div id="drag-overlay" class="drag-overlay">
        <div class="drag-message">📁 Drop files here to upload</div>
    </div>

    <script>
    /**
     * Complete File Explorer v7.2 - Final Script
     * Added Properties/Details modal for files and folders.
     */
    const App = {
        init() {
            this.dom = {
                appContainer: document.getElementById('app-container'),
                contextMenuContainer: document.getElementById('context-menu-container'),
                modalContainer: document.getElementById('modal-container'),
                fileUploader: document.getElementById('file-uploader'),
                fileDownloader: document.getElementById('file-downloader'),
                dragOverlay: document.getElementById('drag-overlay')
            };
            this.VFS.init().then(() => {
                this.ContextMenu.init(this);
                this.Modal.init(this);
                this.DragDrop.init(this);
                this.FileExplorer.init(this);
            }).catch(error => {
                console.error("Failed to initialize VFS:", error);
                alert("File Explorer failed to initialize. Please check console for errors.");
            });
        }
    };

    App.VFS = {
        DB_NAME: 'IndexSpace_VFS_v7_2', // Changed DB name for new version to force re-initialization
        DB_VERSION: 1, // Explicitly set version
        db: null,

        init() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('nodes')) {
                        const store = db.createObjectStore('nodes', { keyPath: 'id' });
                        // Index for efficient listing of children by parentId and name for uniqueness
                        store.createIndex('path', ['parentId', 'name'], { unique: true });
                        // Add other indexes if needed for search performance (e.g., by type, size)
                    }
                };

                req.onsuccess = async e => {
                    this.db = e.target.result;
                    // Ensure 'path' index exists (important for older DBs if upgraded manually)
                    if (!this.db.objectStoreNames.contains('nodes') || !this.db.transaction('nodes', 'readonly').objectStore('nodes').indexNames.contains('path')) {
                        // This case should ideally be handled by onupgradeneeded for higher versions
                        console.warn("IndexedDB 'nodes' store or 'path' index missing. Data might be inconsistent.");
                    }
                    await this.initDefaultFS();
                    resolve();
                };

                req.onerror = e => {
                    console.error("IndexedDB error:", e.target.error);
                    reject(e.target.error);
                };
            });
        },

        async initDefaultFS() {
            // Check for root node
            let rootNode = await this._runTx('nodes', 'readonly', s => s.get('/'));
            if (!rootNode) {
                // If root doesn't exist, create it. name is empty for root as it's the root of the path
                await this._runTx('nodes', 'readwrite', s => s.add({ id: '/', type: 'folder', name: '', parentId: null, ctime: new Date(), mtime: new Date(), size: 0 }));
            }

            // Create default folders if they don't exist
            const defaultPaths = ['/Home', '/Documents', '/.trash'];
            for (const path of defaultPaths) {
                if (!(await this.getNodeByPath(path))) {
                    try {
                        await this.mkdir(path);
                    } catch (e) {
                        console.warn(`Failed to create default folder ${path}: ${e.message}`);
                    }
                }
            }

            // Create a default README.txt if it doesn't exist
            const readmePath = '/Documents/README.txt';
            if (!(await this.getNodeByPath(readmePath))) {
                await this.write(readmePath, 'Welcome to Index-Space File Explorer v7.2!\n\nTry:\n- Double-clicking this file to edit it.\n- Dragging files into this window to upload.\n- Right-clicking for more options.\n- Using keyboard shortcuts (Del, F2, Ctrl+C/X/V).\n- Navigating to the .trash folder to restore items.');
            }

            // Placeholder for an image example (if you want to test image viewing without uploading)
            const imageExamplePath = '/Documents/image_example.png';
            if (!(await this.getNodeByPath(imageExamplePath))) {
                // To have a real image, you'd need to convert base64 or fetch.
                // For now, we'll just create an empty Blob to make the item appear.
                // For actual image viewing, you'd need to upload a real image.
                // Or use a small base64 image here for testing:
                const base64Image = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="; // 1x1 transparent pixel
                const blob = await fetch(base64Image).then(res => res.blob());
                await this.write(imageExamplePath, blob);
            }
        },

        async _runTx(storeName, mode, operation) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, mode);
                const store = tx.objectStore(storeName);
                let req;
                try {
                    req = operation(store);
                } catch (e) {
                    tx.abort(); // Abort transaction if operation itself throws
                    reject(e);
                    return;
                }
                tx.oncomplete = () => resolve(req ? req.result : undefined);
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(tx.error);
            });
        },

        async _getNewId() { return `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; },

        async mkdir(path) {
            if (path === '/') {
                const existingRoot = await this.getNode('/');
                if (!existingRoot) {
                    // Only add if not already there, name is empty for root for path index
                    return this._runTx('nodes', 'readwrite', s => s.add({ id: '/', type: 'folder', name: '', parentId: null, ctime: new Date(), mtime: new Date(), size: 0 }));
                }
                return existingRoot.id;
            }
            const { parentPath, name } = this._parsePath(path);
            const parent = await this.getNodeByPath(parentPath);
            if (!parent || parent.type !== 'folder') throw new Error(`Invalid path: Parent folder '${parentPath}' not found or not a folder`);

            // Check if item with same name already exists in target parent
            const existingNode = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, name]));
            if (existingNode) throw new Error(`An item named '${name}' already exists in '${parentPath}'`);

            const id = await this._getNewId();
            await this._runTx('nodes', 'readwrite', s => s.add({ id, parentId: parent.id, name, type: 'folder', ctime: new Date(), mtime: new Date(), size: 0 }));
            return id;
        },

        async write(path, content = '') {
            const { parentPath, name } = this._parsePath(path);
            const parent = await this.getNodeByPath(parentPath);
            if (!parent || parent.type !== 'folder') throw new Error(`Parent folder '${parentPath}' not found or not a folder`);

            let nodeData;
            let mimeType = '';
            let size = 0;

            if (content instanceof Blob) {
                mimeType = content.type || 'application/octet-stream';
                size = content.size;
            } else { // Assume string content
                mimeType = 'text/plain';
                size = new TextEncoder().encode(String(content)).length; // Accurate byte size for string
            }

            const existingNode = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, name]));
            const now = new Date();
            const id = existingNode ? existingNode.id : await this._getNewId();

            nodeData = {
                id,
                parentId: parent.id,
                name,
                type: 'file',
                content, // Store Blob or String directly
                size,
                mimeType, // Store MIME type for Blobs
                ctime: existingNode ? existingNode.ctime : now,
                mtime: now
            };

            if (existingNode) {
                await this._runTx('nodes', 'readwrite', s => s.put(nodeData)); // Update existing
            } else {
                await this._runTx('nodes', 'readwrite', s => s.add(nodeData)); // Add new
            }
            return id;
        },

        // New function to read file content safely
        async read(id, format = 'string') { // format can be 'string', 'blob', 'dataurl'
            const node = await this.getNode(id);
            if (!node || node.type !== 'file') throw new Error('Not a file or file not found.');

            if (node.content instanceof Blob) {
                if (format === 'blob') return node.content;
                if (format === 'string') return await node.content.text();
                if (format === 'dataurl') {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(node.content);
                    });
                }
                return node.content; // Default to Blob if format not recognized
            } else { // Assume content is string
                if (format === 'string') return String(node.content || '');
                // Attempt to convert string to Blob for download/dataurl if needed, but might lose original mimeType
                if (format === 'blob') return new Blob([String(node.content || '')], { type: node.mimeType || 'text/plain' });
                if (format === 'dataurl') {
                    const blob = new Blob([String(node.content || '')], { type: node.mimeType || 'text/plain' });
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                }
                return String(node.content || '');
            }
        },

        async list(path) {
            const p = await this.getNodeByPath(path);
            if (!p) return [];
            return this._runTx('nodes', 'readonly', s => s.index('path').getAll(IDBKeyRange.bound([p.id, ''], [p.id, '\uffff'])));
        },

        async delete(id) {
            const n = await this.getNode(id);
            if (!n) return;
            if (n.type === 'folder') {
                const c = await this.list(await this.constructPath(id));
                for (const i of c) await this.delete(i.id);
            }
            await this._runTx('nodes', 'readwrite', s => s.delete(id));
        },

        async rename(id, newName) {
            const nodeToRename = await this.getNode(id);
            if (!nodeToRename) throw new Error('Node not found for rename.');
            if (nodeToRename.id === '/') throw new Error("Cannot rename root folder.");

            const parent = await this.getNode(nodeToRename.parentId);
            if (parent) {
                const existing = await this._runTx('nodes', 'readonly', s => s.index('path').get([parent.id, newName]));
                if (existing && existing.id !== nodeToRename.id) {
                    throw new Error(`An item named '${newName}' already exists in this folder.`);
                }
            }

            await this._runTx('nodes', 'readwrite', s => {
                s.get(id).onsuccess = e => {
                    const n = e.target.result;
                    n.name = newName;
                    n.mtime = new Date();
                    s.put(n);
                }
            });
        },

        async move(id, newParentPath) {
            const targetParent = await this.getNodeByPath(newParentPath);
            if (!targetParent || targetParent.type !== 'folder') throw new Error(`Invalid target path: '${newParentPath}' is not a folder or does not exist.`);

            const nodeToMove = await this.getNode(id);
            if (!nodeToMove) throw new Error('Node not found for move.');
            if (nodeToMove.id === '/') throw new Error("Cannot move root folder.");
            if (nodeToMove.parentId === targetParent.id) return; // Already in target folder

            // Prevent moving a folder into itself or its sub-folder
            let currentCheckId = targetParent.id;
            while(currentCheckId && currentCheckId !== '/') {
                if (currentCheckId === nodeToMove.id) {
                    throw new Error("Cannot move a folder into itself or its sub-folder.");
                }
                const checkNode = await this.getNode(currentCheckId);
                currentCheckId = checkNode ? checkNode.parentId : null;
            }


            // Check for name conflict in target folder
            const existingNodeInTarget = await this._runTx('nodes', 'readonly', s => s.index('path').get([targetParent.id, nodeToMove.name]));
            if (existingNodeInTarget) {
                throw new Error(`An item named '${nodeToMove.name}' already exists in the target folder.`);
            }

            await this._runTx('nodes', 'readwrite', s => {
                s.get(id).onsuccess = e => {
                    const n = e.target.result;
                    n.parentId = targetParent.id;
                    n.mtime = new Date();
                    s.put(n);
                }
            });
        },

        async copy(id, newParentPath) {
            const n = await this.getNode(id);
            if(!n) return;

            const targetParent = await this.getNodeByPath(newParentPath);
            if (!targetParent || targetParent.type !== 'folder') throw new Error(`Invalid target path: '${newParentPath}' is not a folder or does not exist.`);

            let newName = n.name;
            let counter = 1;
            let targetPathFull = `${newParentPath === '/' ? '' : newParentPath}/${newName}`;

            // Handle naming conflicts for copy
            while (await this.getNodeByPath(targetPathFull)) {
                const nameParts = n.name.split('.');
                const baseName = nameParts.slice(0, -1).join('.');
                const ext = nameParts.length > 1 ? `.${nameParts[nameParts.length - 1]}` : '';

                if (counter === 1) { // First try with "(Copy)" before extension
                     newName = `${baseName}(Copy)${ext}`;
                } else { // Subsequent tries with (Copy X)
                    newName = `${baseName}(Copy ${counter})${ext}`;
                }
                targetPathFull = `${newParentPath === '/' ? '' : newParentPath}/${newName}`;
                counter++;
            }

            if (n.type === 'folder') {
                const newFolderId = await this.mkdir(`${newParentPath === '/' ? '' : newParentPath}/${newName}`);
                const children = await this.list(await this.constructPath(id));
                for (const child of children) {
                    await this.copy(child.id, await this.constructPath(newFolderId));
                }
                return newFolderId;
            } else {
                // Ensure content is copied, not just reference
                const copiedContent = n.content instanceof Blob ? n.content : String(n.content || '');
                const newFileId = await this.write(`${newParentPath === '/' ? '' : newParentPath}/${newName}`, copiedContent);
                return newFileId;
            }
        },

        async getNode(id) {
            return this._runTx('nodes', 'readonly', s => s.get(id));
        },

        async getNodeByPath(path) {
            if (path === '/') return this.getNode('/');
            let pid = '/';
            let n = null;
            // Filter(Boolean) removes empty strings from split, preventing // issues
            const pathParts = path.split('/').filter(Boolean);
            for (const name of pathParts) {
                n = await this._runTx('nodes', 'readonly', s => s.index('path').get([pid, name]));
                if (!n) return null; // Part of path not found
                pid = n.id;
            }
            return n; // Return the final node
        },

        async constructPath(id) {
            if (id === '/') return '/';
            let p = [];
            let n = await this.getNode(id);
            if (!n) return null; // Node not found

            while (n && n.parentId !== null) { // Stop when parentId is null (root)
                p.unshift(n.name);
                if (n.parentId === '/') break; // Stop at the actual root folder node
                n = await this.getNode(n.parentId);
            }
            return `/${p.join('/')}`;
        },

        _parsePath(path) {
            const p = path.split('/').filter(Boolean);
            const name = p.pop() || ''; // Last part is name, or empty string for root
            const parentPath = `/${p.join('/')}`; // Remaining parts form parent path
            return { parentPath: parentPath === '' ? '/' : parentPath, name }; // Ensure root parent is '/'
        },

        async findNodesByContent(query) {
            const results = [];
            const lowerCaseQuery = query.toLowerCase();
            await this._runTx('nodes', 'readonly', store => {
                const request = store.openCursor();
                request.onsuccess = async e => {
                    const cursor = e.target.result;
                    if (cursor) {
                        const node = cursor.value;
                        // Only search text content for text-like files, defined by mimeType starting with 'text/'
                        if (node.type === 'file' && node.mimeType && node.mimeType.startsWith('text/')) {
                            try {
                                const contentString = await this.read(node.id, 'string');
                                if (contentString.toLowerCase().includes(lowerCaseQuery)) {
                                    results.push(node);
                                }
                            } catch (readError) {
                                console.warn(`Could not read content for search: ${node.name}`, readError);
                            }
                        }
                        cursor.continue();
                    }
                };
            });
            return results;
        }
    };

    App.ContextMenu = {
        init(app) {
            this.app = app;
            this.container = app.dom.contextMenuContainer;
            window.addEventListener('click', () => this.hide(), true);
            this.container.addEventListener('contextmenu', e=>e.stopPropagation());
        },
        show(x, y, items) {
            this.hide();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            // Adjust position to stay within viewport
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;

            // Render items
            items.forEach(item => {
                if (!item) {
                    menu.appendChild(document.createElement('div')).className = 'context-menu-divider';
                    return;
                }
                const itemEl = document.createElement('div');
                itemEl.className = `context-menu-item ${item.disabled ? 'disabled' : ''}`;
                itemEl.textContent = item.label;
                if (!item.disabled) itemEl.onclick = e => {
                    e.stopPropagation();
                    this.hide();
                    item.action();
                };
                menu.appendChild(itemEl);
            });
            this.container.appendChild(menu);

            // Post-render position adjustment for bounds
            // Must be done AFTER appending to DOM so getBoundingClientRect is accurate
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = `${Math.max(0, x - rect.width)}px`; // Ensure it doesn't go off left edge
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = `${Math.max(0, y - rect.height)}px`; // Ensure it doesn't go off top edge
                }
                menu.classList.add('visible');
            }, 0);
        },
        hide() { this.container.innerHTML = ''; }
    };

    App.Modal = {
        init(app) { this.app = app; this.container = app.dom.modalContainer; },
        _createModal(contentHtml, buttonsHtml, onClose) {
            this.container.innerHTML = `<div class="modal-overlay"><div class="modal-dialog">
                ${contentHtml}
                <div class="modal-buttons">${buttonsHtml}</div>
            </div></div>`;
            const overlay = this.container.querySelector('.modal-overlay');
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) { // Only close if clicked on overlay, not dialog
                    this.close();
                    if (onClose) onClose();
                }
            });
            // Allow closing with Escape key
            document.addEventListener('keydown', this._handleEscapeKey);
        },
        _handleEscapeKey: (e) => {
            if (e.key === 'Escape') {
                App.Modal.close();
                document.removeEventListener('keydown', App.Modal._handleEscapeKey);
            }
        },
        confirm({ title, message, onConfirm, onCancel }) {
            const content = `<h3>${title}</h3><p>${message}</p>`;
            const buttons = `<button class="cancel-btn">Cancel</button><button class="confirm-btn danger-btn">Confirm</button>`;
            this._createModal(content, buttons);

            this.container.querySelector('.cancel-btn').onclick = () => { this.close(); if(onCancel) onCancel(); };
            this.container.querySelector('.confirm-btn').onclick = () => { this.close(); onConfirm(); };
        },
        prompt({ title, message, defaultValue = '', onConfirm, onCancel }) {
            const content = `<h3>${title}</h3><p>${message}</p><input type="text" value="${defaultValue}" class="modal-input" style="width: 100%; padding: 8px; margin-bottom: 15px; border-radius: 4px; border: 1px solid var(--color-border); background: var(--color-surface-2); color: var(--color-text-primary);" />`;
            const buttons = `<button class="cancel-btn">Cancel</button><button class="confirm-btn primary-btn">OK</button>`;
            this._createModal(content, buttons, onCancel);

            const input = this.container.querySelector('.modal-input');
            input.focus();
            input.select();
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    this.close();
                    onConfirm(input.value);
                } else if (e.key === 'Escape') {
                    this.close();
                    if(onCancel) onCancel();
                }
            };
            this.container.querySelector('.cancel-btn').onclick = () => { this.close(); if(onCancel) onCancel(); };
            this.container.querySelector('.confirm-btn').onclick = () => { this.close(); onConfirm(input.value); };
        },
        viewFile({ title, contentHtml, onSave, onClose }) {
            let buttons = '';
            if (onSave) {
                buttons = `<button class="save-btn success-btn">Save</button><button class="close-btn">Close</button>`;
            } else {
                buttons = `<button class="close-btn primary-btn">Close</button>`;
            }
            const content = `<h3>${title}</h3><div class="file-viewer-content">${contentHtml}</div>`;
            this._createModal(content, buttons, onClose); // Pass onClose to _createModal

            if (onSave) {
                this.container.querySelector('.save-btn').onclick = () => {
                    const textArea = this.container.querySelector('.file-viewer-content textarea');
                    if (textArea) onSave(textArea.value);
                    this.close();
                };
            }
            this.container.querySelector('.close-btn').onclick = () => { this.close(); if(onClose) onClose(); };
        },
        // New modal type for showing properties
        showProperties({ title, contentHtml, onClose }) {
            const content = `<h3>${title}</h3><div class="properties-content">${contentHtml}</div>`;
            const buttons = `<button class="close-btn primary-btn">Close</button>`;
            this._createModal(content, buttons, onClose);
            this.container.querySelector('.close-btn').onclick = () => { this.close(); if(onClose) onClose(); };
        },
        close() {
            this.container.innerHTML = '';
            document.removeEventListener('keydown', this._handleEscapeKey);
        }
    };

    App.DragDrop = {
        init(app) {
            this.app = app;
            this.overlay = app.dom.dragOverlay;
            // Use window for dragenter/dragleave to show/hide overlay globally
            window.addEventListener('dragenter', this.onWindowDragEnter.bind(this));
            window.addEventListener('dragleave', this.onWindowDragLeave.bind(this));
            this.overlay.addEventListener('dragover', e => e.preventDefault()); // Necessary to allow drop
            this.overlay.addEventListener('drop', this.onDrop.bind(this));
        },
        dragCounter: 0, // To handle nested dragenter/dragleave events
        onWindowDragEnter(e) {
            e.preventDefault();
            this.dragCounter++;
            this.overlay.classList.add('active');
        },
        onWindowDragLeave(e) {
            e.preventDefault();
            this.dragCounter--;
            // Only hide if the cursor is actually leaving the window/app
            if (this.dragCounter === 0) {
                this.overlay.classList.remove('active');
            }
        },
        async onDrop(e) {
            e.preventDefault();
            this.dragCounter = 0; // Reset counter
            this.overlay.classList.remove('active');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                // Ensure the FileExplorer's upload function is called with proper context
                await this.app.FileExplorer.uploadFiles(files);
            }
        }
    };

    App.FileExplorer = {
        init(app) {
            this.app = app;
            this.currentPath = '/';
            this.selection = new Set();
            this.clipboard = { mode: null, itemIds: [] }; // mode: 'copy' or 'cut'
            this.history = ['/'];
            this.historyIndex = 0;
            this.sort = { key: 'name', order: 'asc' };
            this.items = []; // Current items displayed
            this.lastClickedId = null; // For Shift-select
            this.listView = true; // true for list, false for grid

            this.app.dom.appContainer.innerHTML = `
                <div class="explorer-toolbar">
                    <button class="nav-btn back-btn" title="Back">←</button>
                    <button class="nav-btn fwd-btn" title="Forward">→</button>
                    <button class="nav-btn up-btn" title="Up">↑</button>
                    <input type="text" class="path-bar" />
                    <input type="search" class="search-bar" placeholder="Search..." />
                    <select id="file-type-filter">
                        <option value="all">All Files</option>
                        <option value="folder">Folders</option>
                        <option value="text">Text Files</option>
                        <option value="image">Images</option>
                        <option value="archive">Archives</option>
                        <option value="other">Other</option>
                    </select>
                    <div class="view-controls">
                        <button class="view-control-btn list-view-btn active" title="List View">☰</button>
                        <button class="view-control-btn grid-view-btn" title="Grid View">🗇</button>
                    </div>
                    <button class="nav-btn upload-btn" title="Upload">📥</button>
                </div>
                <div class="explorer-body">
                    <div class="sidebar">
                        <h3>Favorites</h3>
                        <div class="quick-access-item" data-path="/Home">🏠 Home</div>
                        <div class="quick-access-item" data-path="/Documents">📄 Documents</div>
                        <div class="quick-access-item" data-path="/.trash">🗑️ Trash</div>
                    </div>
                    <div class="explorer-main">
                        <div class="content-area"></div>
                    </div>
                </div>
                <div class="explorer-statusbar"></div>
            `;
            this.dom = {
                sidebar: app.dom.appContainer.querySelector('.sidebar'),
                pathBar: app.dom.appContainer.querySelector('.path-bar'),
                searchBar: app.dom.appContainer.querySelector('.search-bar'),
                fileTypeFilter: app.dom.appContainer.querySelector('#file-type-filter'),
                contentArea: app.dom.appContainer.querySelector('.content-area'),
                statusBar: app.dom.appContainer.querySelector('.explorer-statusbar'),
                toolbar: app.dom.appContainer.querySelector('.explorer-toolbar'),
                listViewBtn: app.dom.appContainer.querySelector('.list-view-btn'),
                gridViewBtn: app.dom.appContainer.querySelector('.grid-view-btn'),
            };

            this.render();
            this.bindEvents();
        },
        async render() {
            let items = [];
            try {
                items = await this.app.VFS.list(this.currentPath);
            } catch (error) {
                console.error(`Error listing items for path ${this.currentPath}:`, error);
                alert(`Error loading folder: ${error.message}`);
                // Attempt to navigate to root if current path is broken
                if (this.currentPath !== '/') {
                    this.navigate('/');
                    return;
                }
                items = []; // Clear items if path is truly broken
            }


            // Apply search filter
            const searchTerm = this.dom.searchBar.value.toLowerCase();
            if (searchTerm) {
                const pathFiltered = items.filter(item => item.name.toLowerCase().includes(searchTerm));
                // Only search content for text-like files, and only if search term exists
                const contentFiltered = await this.app.VFS.findNodesByContent(searchTerm);
                // Combine and de-duplicate results
                items = [...new Map([...pathFiltered, ...contentFiltered].map(item => [item.id, item])).values()];
            }

            // Apply type filter
            const fileTypeFilterValue = this.dom.fileTypeFilter.value;
            if (fileTypeFilterValue !== 'all') {
                items = items.filter(item => {
                    const ext = item.type === 'file' && item.name.includes('.') ? item.name.split('.').pop().toLowerCase() : '';
                    switch (fileTypeFilterValue) {
                        case 'folder': return item.type === 'folder';
                        case 'text': return item.type === 'file' && ['txt', 'md', 'js', 'html', 'css', 'json', 'xml'].includes(ext);
                        case 'image': return item.type === 'file' && ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext);
                        case 'archive': return item.type === 'file' && ['zip', 'rar', 'tar', 'gz'].includes(ext);
                        case 'other':
                            // Exclude known types
                            return item.type === 'file' && ![
                                'txt', 'md', 'js', 'html', 'css', 'json', 'xml', // Text
                                'jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', // Images
                                'zip', 'rar', 'tar', 'gz', // Archives
                                'mp3', 'wav', 'ogg', // Audio (if you add audio icons)
                                'mp4', 'webm', 'ogv', // Video (if you add video icons)
                                'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx' // Documents (if you add doc icons)
                            ].includes(ext);
                        default: return true;
                    }
                });
            }

            // Sort items
            items.sort((a, b) => {
                // Folders always come first
                if (a.type === 'folder' && b.type !== 'folder') return -1;
                if (a.type !== 'folder' && b.type === 'folder') return 1;

                const valA = a[this.sort.key] || '';
                const valB = b[this.sort.key] || '';
                let comparison;
                if (this.sort.key === 'size') { // Sort by actual size for files
                    comparison = (a.type === 'file' ? a.size : -1) - (b.type === 'file' ? b.size : -1);
                } else if (typeof valA === 'string') {
                    comparison = valA.localeCompare(valB, undefined, { sensitivity: 'base' });
                } else {
                    comparison = valA > valB ? 1 : (valA < valB ? -1 : 0);
                }
                return this.sort.order === 'desc' ? comparison * -1 : comparison;
            });

            this.items = items;
            this.dom.contentArea.innerHTML = '';

            // Apply view mode class to content area
            this.dom.contentArea.className = `content-area ${this.listView ? 'file-list' : 'file-grid'}`;

            // Add list header only for list view
            if (this.listView) {
                this.dom.contentArea.appendChild(this.createListHeaderElement());
            }

            items.forEach(item => this.dom.contentArea.appendChild(this.createItemElement(item)));

            this.dom.pathBar.value = this.currentPath;
            this.updateNavButtons();
            this.updateStatusBar();
            this.updateSelection();
            this.updateViewButtons();
            this.updateSidebarActiveItem();
        },
        createListHeaderElement() {
            const h = document.createElement('div');
            h.className = 'list-header';
            h.innerHTML = `
                <div class="list-header-item list-col-name" data-sort-key="name">Name</div>
                <div class="list-header-item list-col-size" data-sort-key="size">Size</div>
                <div class="list-header-item list-col-date" data-sort-key="mtime">Date Modified</div>
            `;
            const currentSortHeader = h.querySelector(`[data-sort-key="${this.sort.key}"]`);
            if (currentSortHeader) {
                currentSortHeader.classList.add(this.sort.order === 'asc' ? 'sort-asc' : 'sort-desc');
            }
            return h;
        },
        createItemElement(item) {
            const e = document.createElement('div');
            e.className = `file-item`; // Base class
            e.dataset.id = item.id;
            e.draggable = true; // Enable drag

            e.innerHTML = `
                <div class="file-item-icon">${this.getIcon(item)}</div>
                <div class="file-item-name">${item.name}</div>
                ${item.type === 'file' ? `<div class="file-item-meta list-col-size">${this.formatBytes(item.size)}</div>` : '<div class="file-item-meta list-col-size">—</div>'}
                <div class="file-item-meta list-col-date">${new Date(item.mtime).toLocaleString()}</div>
            `;
            return e;
        },
        bindEvents() {
            const t = this.dom.toolbar;

            t.querySelector('.back-btn').onclick = () => this.navigateHistory(-1);
            t.querySelector('.fwd-btn').onclick = () => this.navigateHistory(1);
            t.querySelector('.up-btn').onclick = () => {
                const parsedPath = this.app.VFS._parsePath(this.currentPath);
                if (parsedPath.parentPath !== this.currentPath) { // Prevent navigating up from root
                    this.navigate(parsedPath.parentPath);
                }
            };
            t.querySelector('.upload-btn').onclick = () => this.app.dom.fileUploader.click();
            this.app.dom.fileUploader.onchange = async e => {
                if (e.target.files.length > 0) {
                    await this.uploadFiles(e.target.files);
                }
                e.target.value = null; // Clear input for next upload
            };

            this.dom.pathBar.onkeydown = e => {
                if (e.key === 'Enter') {
                    this.navigate(this.dom.pathBar.value);
                }
            };
            this.dom.searchBar.oninput = () => this.render();
            this.dom.fileTypeFilter.onchange = () => this.render();

            // View controls
            this.dom.listViewBtn.onclick = () => { this.listView = true; this.render(); };
            this.dom.gridViewBtn.onclick = () => { this.listView = false; this.render(); };

            this.dom.contentArea.addEventListener('click', e => {
                const headerItem = e.target.closest('.list-header-item');
                if (headerItem) {
                    this.handleSort(headerItem.dataset.sortKey);
                    return;
                }
                this.handleSelection(e, e.target.closest('.file-item'));
            });

            this.dom.contentArea.addEventListener('dblclick', async e => {
                const itemEl = e.target.closest('.file-item');
                if (!itemEl) return;
                const node = await this.app.VFS.getNode(itemEl.dataset.id);
                if (!node) return;

                if (node.type === 'folder') {
                    this.navigate(await this.app.VFS.constructPath(node.id));
                } else if (node.type === 'file') {
                    this.openFileInViewer(node);
                }
            });

            this.dom.contentArea.addEventListener('contextmenu', e => {
                e.preventDefault();
                e.stopPropagation();
                const itemEl = e.target.closest('.file-item');
                // Ensure context menu is shown for selected items or the clicked item
                if (itemEl) {
                    if (!this.selection.has(itemEl.dataset.id)) {
                        this.selection.clear();
                        this.selection.add(itemEl.dataset.id);
                        this.updateSelection();
                    }
                } else {
                    this.selection.clear(); // Clear selection if right-clicked on empty space
                    this.updateSelection();
                }
                this.app.ContextMenu.show(e.clientX, e.clientY, itemEl ? this.getItemContextMenu() : this.getGridContextMenu());
            });

            this.dom.sidebar.querySelectorAll('.quick-access-item').forEach(el => {
                el.onclick = () => this.navigate(el.dataset.path);
            });

            // Keyboard Shortcuts (global listener for most actions)
            document.addEventListener('keydown', e => this.handleKeyboardShortcut(e));

            // Drag and Drop (inside explorer) - for items being dragged *within* the explorer
            this.dom.contentArea.ondragstart = e => {
                const itemEl = e.target.closest('.file-item');
                if(itemEl){
                    if (!this.selection.has(itemEl.dataset.id)) {
                        this.selection.clear();
                        this.selection.add(itemEl.dataset.id);
                        this.updateSelection();
                    }
                    e.dataTransfer.setData('text/plain', JSON.stringify([...this.selection]));
                    e.dataTransfer.effectAllowed = 'move';
                }
            };

            this.dom.contentArea.ondragover = e => {
                e.preventDefault();
                // Remove all previous drag-over highlights
                this.dom.contentArea.querySelectorAll('.file-item.drag-over').forEach(el => el.classList.remove('drag-over'));

                const targetItemEl = e.target.closest('.file-item');
                if (targetItemEl) {
                    this.app.VFS.getNode(targetItemEl.dataset.id).then(node => {
                        // Prevent dragging a folder onto itself or into its children
                        if (node.type === 'folder') {
                            const selectedIds = [...this.selection];
                            let isInvalidTarget = false;
                            for (const selectedId of selectedIds) {
                                // Check if target node is the same as a selected node
                                if (selectedId === node.id) {
                                    isInvalidTarget = true;
                                    break;
                                }
                                // Check if target node is a child of a selected folder
                                let currentParentId = node.parentId;
                                while(currentParentId) {
                                    if (currentParentId === selectedId) {
                                        const selectedNode = this.items.find(item => item.id === selectedId);
                                        if (selectedNode && selectedNode.type === 'folder') {
                                            isInvalidTarget = true;
                                            break;
                                        }
                                    }
                                    const parentNode = this.items.find(item => item.id === currentParentId);
                                    currentParentId = parentNode ? parentNode.parentId : null;
                                }
                                if (isInvalidTarget) break;
                            }

                            if (!isInvalidTarget) {
                                targetItemEl.classList.add('drag-over');
                            }
                        }
                    });
                }
            };

            this.dom.contentArea.ondragleave = e => {
                // Ensure drag-over is removed only if leaving the actual item
                if (e.target.closest('.file-item') && !e.relatedTarget.closest('.file-item')) {
                    e.target.closest('.file-item').classList.remove('drag-over');
                }
            };

            this.dom.contentArea.ondrop = async e => {
                e.preventDefault();
                this.dom.contentArea.querySelectorAll('.file-item.drag-over').forEach(el => el.classList.remove('drag-over'));
                const targetItemEl = e.target.closest('.file-item');
                let targetPath = this.currentPath; // Default to current folder if dropped on empty area

                if (targetItemEl) {
                    const targetNode = await this.app.VFS.getNode(targetItemEl.dataset.id);
                    if (targetNode && targetNode.type === 'folder') {
                        targetPath = await this.app.VFS.constructPath(targetNode.id);
                    } else {
                        // If dropped on a file, move to its parent folder
                        targetPath = this.currentPath;
                    }
                }

                const draggedItemIds = JSON.parse(e.dataTransfer.getData('text/plain'));
                for(const id of draggedItemIds) {
                    const itemNode = await this.app.VFS.getNode(id);
                    if (!itemNode) continue;

                    const itemCurrentPath = await this.app.VFS.constructPath(id);
                    const itemParsed = this.app.VFS._parsePath(itemCurrentPath);

                    if (itemNode.parentId === (await this.app.VFS.getNodeByPath(targetPath))?.id) {
                        // Item already in target folder, skip
                        continue;
                    }

                    try {
                        await this.app.VFS.move(id, targetPath);
                    } catch (error) {
                        alert(`Error moving '${itemParsed.name}': ${error.message}`);
                    }
                }
                this.render();
            };
        },
        handleKeyboardShortcut(e) {
            // Check if focus is not on path bar or search bar or renaming element during shortcuts
            const activeEl = document.activeElement;
            const isInputFocused = activeEl === this.dom.pathBar ||
                                   activeEl === this.dom.searchBar ||
                                   activeEl.classList.contains('renaming') ||
                                   activeEl.tagName === 'TEXTAREA'; // For modal textareas

            if (isInputFocused && !['Enter', 'Escape'].includes(e.key)) {
                // Allow Enter and Escape for input fields
                return;
            }

            const isCtrlOrCmd = e.ctrlKey || e.metaKey; // metaKey for Cmd on Mac

            switch (e.key) {
                case 'Delete':
                case 'Backspace': // Treat Backspace as Delete for convenience outside inputs
                    if (this.selection.size > 0 && !isInputFocused) {
                        e.preventDefault(); // Prevent browser back navigation for Backspace
                        this.deleteSelection();
                    }
                    break;
                case 'F2':
                    e.preventDefault();
                    if (this.selection.size === 1) {
                        const selectedEl = this.dom.contentArea.querySelector(`[data-id="${[...this.selection][0]}"]`);
                        if (selectedEl) {
                            this.startRename(selectedEl);
                        }
                    }
                    break;
                case 'c':
                    if (isCtrlOrCmd) {
                        e.preventDefault();
                        this.copySelection();
                    }
                    break;
                case 'x':
                    if (isCtrlOrCmd) {
                        e.preventDefault();
                        this.cutSelection();
                    }
                    break;
                case 'v':
                    if (isCtrlOrCmd) {
                        e.preventDefault();
                        this.pasteSelection();
                    }
                    break;
                case 'n':
                    if (isCtrlOrCmd) {
                        e.preventDefault();
                        if (e.shiftKey) { // Ctrl+Shift+N for new file
                            this.createNewItem('file');
                        } else { // Ctrl+N for new folder
                            this.createNewItem('folder');
                        }
                    }
                    break;
                case 'a':
                    if (isCtrlOrCmd) {
                        e.preventDefault();
                        this.selection.clear();
                        this.items.forEach(item => this.selection.add(item.id));
                        this.updateSelection();
                    }
                    break;
                case 'ArrowLeft':
                    if (isCtrlOrCmd) { e.preventDefault(); this.navigateHistory(-1); }
                    break;
                case 'ArrowRight':
                    if (isCtrlOrCmd) { e.preventDefault(); this.navigateHistory(1); }
                    break;
                case 'ArrowUp':
                    if (isCtrlOrCmd && e.shiftKey) { e.preventDefault(); this.navigate(this.app.VFS._parsePath(this.currentPath).parentPath); }
                    break;
            }
        },
        handleSort(key) {
            if(this.sort.key === key) {
                this.sort.order = this.sort.order === 'asc' ? 'desc' : 'asc';
            } else {
                this.sort.key = key;
                this.sort.order = 'asc';
            }
            this.render();
        },
        handleSelection(e, itemEl) {
            const allItems = [...this.dom.contentArea.querySelectorAll('.file-item')];

            if (itemEl) {
                const id = itemEl.dataset.id;
                if (e.shiftKey && this.lastClickedId) {
                    const lastIdx = allItems.findIndex(el => el.dataset.id === this.lastClickedId);
                    const currentIdx = allItems.findIndex(el => el.dataset.id === id);
                    const [start, end] = [lastIdx, currentIdx].sort((a,b)=>a-b);
                    // Clear existing selection only if it's not part of the shift-selection
                    if (!(e.ctrlKey || e.metaKey)) { // Only clear if Ctrl/Cmd isn't held
                       this.selection.clear();
                    }
                    for (let i = start; i <= end; i++) {
                        this.selection.add(allItems[i].dataset.id);
                    }
                } else if (e.ctrlKey || e.metaKey) { // Ctrl for Windows/Linux, Cmd for Mac
                    if (this.selection.has(id)) {
                        this.selection.delete(id);
                    } else {
                        this.selection.add(id);
                    }
                } else { // No modifier key
                    // If already selected and only one item selected, don't clear (for rename)
                    if (this.selection.size === 1 && this.selection.has(id)) {
                        // Do nothing, keep selection
                    } else {
                        this.selection.clear();
                        this.selection.add(id);
                    }
                }
                this.lastClickedId = id;
            } else { // Clicked on empty space
                this.selection.clear();
                this.lastClickedId = null;
            }
            this.updateSelection();
        },
        getItemContextMenu() {
            const selectedItemIds = [...this.selection];
            const hasSelection = selectedItemIds.length > 0;
            const isSingleSelection = selectedItemIds.length === 1;
            const isTrashFolder = this.currentPath === '/.trash';

            let items = [
                { label: 'Open', action: async () => {
                    if (isSingleSelection) {
                        const node = await this.app.VFS.getNode(selectedItemIds[0]);
                        if (node) this.openFileInViewer(node);
                    }
                }, disabled: !isSingleSelection || this.items.find(i => i.id === selectedItemIds[0])?.type !== 'file' },
                // --- Properties (Added) ---
                { label: '속성 (Properties)', action: () => this.showProperties(selectedItemIds[0]), disabled: !isSingleSelection },
                null,
                { label: 'Cut (Ctrl+X)', action: () => this.cutSelection(), disabled: !hasSelection || isTrashFolder },
                { label: 'Copy (Ctrl+C)', action: () => this.copySelection(), disabled: !hasSelection || isTrashFolder },
                { label: 'Paste (Ctrl+V)', action: () => this.pasteSelection(), disabled: !this.clipboard.itemIds.length || isTrashFolder },
                null,
                { label: 'Rename (F2)', action: () => {
                    if (isSingleSelection) {
                        const selectedEl = this.dom.contentArea.querySelector(`[data-id="${selectedItemIds[0]}"]`);
                        if (selectedEl) this.startRename(selectedEl);
                    }
                }, disabled: !isSingleSelection || isTrashFolder || selectedItemIds[0] === '/' }, // Cannot rename root
            ];

            if (isTrashFolder) {
                items.push(
                    { label: 'Restore', action: () => this.restoreSelection(), disabled: !hasSelection },
                    { label: 'Delete Permanently', action: () => this.deletePermanentlySelection(), disabled: !hasSelection }
                );
            } else {
                items.push(
                    { label: 'Delete (Del)', action: () => this.deleteSelection(), disabled: !hasSelection || selectedItemIds[0] === '/' } // Cannot delete root
                );
            }

            items.push(
                null,
                { label: 'Download', action: async () => {
                    if (isSingleSelection) {
                        const node = await this.app.VFS.getNode(selectedItemIds[0]);
                        if (node && node.type === 'file') {
                            this.downloadItem(node.id);
                        } else {
                            alert('Only single files can be downloaded directly.');
                        }
                    } else if (selectedItemIds.length > 1) {
                         alert('Multiple file download is not yet supported. Please select one file.');
                    }
                }, disabled: !isSingleSelection || this.items.find(i => i.id === selectedItemIds[0])?.type !== 'file' }
            );

            return items;
        },
        getGridContextMenu() {
            const isTrashFolder = this.currentPath === '/.trash';
            return [
                { label: 'Paste (Ctrl+V)', action: () => this.pasteSelection(), disabled: !this.clipboard.itemIds.length || isTrashFolder },
                null,
                { label: 'New Folder (Ctrl+N)', action: () => this.createNewItem('folder'), disabled: isTrashFolder },
                { label: 'New Text File (Ctrl+Shift+N)', action: () => this.createNewItem('file'), disabled: isTrashFolder },
            ];
        },
        async createNewItem(type) {
            this.app.Modal.prompt({
                title: `Create New ${type === 'folder' ? 'Folder' : 'Text File'}`,
                message: `Enter name for new ${type}:`,
                defaultValue: `New ${type === 'folder' ? (type === 'file' ? 'File' : 'Folder') : 'File'}`,
                onConfirm: async (name) => {
                    if (!name || name.trim() === '') {
                        alert('Name cannot be empty.');
                        return;
                    }
                    const fullPath = `${this.currentPath === '/' ? '' : this.currentPath}/${name}`;
                    try {
                        if (type === 'folder') {
                            await this.app.VFS.mkdir(fullPath);
                        } else {
                            await this.app.VFS.write(fullPath);
                        }
                        this.render();
                    } catch (error) {
                        alert(`Error creating ${type}: ${error.message}`);
                    }
                }
            });
        },
        startRename(itemEl) {
            if(!itemEl) return;
            const nodeId = itemEl.dataset.id;
            if (nodeId === '/') { // Prevent renaming root
                alert("Cannot rename root folder.");
                return;
            }
            const nameEl = itemEl.querySelector('.file-item-name');
            const originalName = nameEl.textContent;
            nameEl.contentEditable = true;
            nameEl.classList.add('renaming');
            nameEl.focus();

            // Select all text in contenteditable div
            const range = document.createRange();
            range.selectNodeContents(nameEl);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            const finishRename = async () => {
                nameEl.contentEditable = false;
                nameEl.classList.remove('renaming');
                const newName = nameEl.textContent.trim();
                if (!newName) { // Name cannot be empty
                    alert('File/folder name cannot be empty.');
                    nameEl.textContent = originalName; // Revert
                    this.render();
                    return;
                }
                if (newName !== originalName) {
                    try {
                        await this.app.VFS.rename(nodeId, newName);
                    } catch (error) {
                        alert(`Error renaming: ${error.message}`);
                        nameEl.textContent = originalName; // Restore original name on error
                    }
                } else {
                    nameEl.textContent = originalName; // If name is same, revert just in case
                }
                this.render(); // Re-render to ensure correct state and selection
            };

            nameEl.onblur = finishRename;
            nameEl.onkeydown = e => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent new line in contenteditable
                    finishRename();
                } else if (e.key === 'Escape') {
                    nameEl.contentEditable = false;
                    nameEl.classList.remove('renaming');
                    nameEl.textContent = originalName; // Revert name
                    this.render(); // Re-render to clear highlighting etc.
                }
            };
        },
        deleteSelection() {
            if (!this.selection.size) return;
            const itemsToDelete = [...this.selection].map(id => this.items.find(i => i.id === id)).filter(Boolean);
            const rootItemAttempt = itemsToDelete.some(item => item.id === '/');
            if (rootItemAttempt) {
                alert("Cannot move the root folder to Trash.");
                return;
            }

            const itemNames = itemsToDelete.map(item => `'${item.name}'`).join(', ');
            this.app.Modal.confirm({
                title: 'Move to Trash',
                message: `Are you sure you want to move ${this.selection.size} item(s) to Trash? \n\n(${itemNames})`,
                onConfirm: async () => {
                    for (const id of this.selection) {
                        try {
                            if (id !== '/') { // Ensure root cannot be trashed
                                await this.app.VFS.move(id, '/.trash');
                            }
                        } catch (error) {
                            alert(`Error moving '${this.items.find(i => i.id === id)?.name || 'item'}' to Trash: ${error.message}`);
                        }
                    }
                    this.selection.clear();
                    this.render();
                }
            });
        },
        deletePermanentlySelection() {
            if (!this.selection.size) return;
            const itemsToDelete = [...this.selection].map(id => this.items.find(i => i.id === id)).filter(Boolean);
            const itemNames = itemsToDelete.map(item => `'${item.name}'`).join(', ');
            this.app.Modal.confirm({
                title: 'Delete Permanently',
                message: `Are you sure you want to permanently delete ${this.selection.size} item(s)? This action cannot be undone. \n\n(${itemNames})`,
                onConfirm: async () => {
                    for (const id of this.selection) {
                        try {
                            await this.app.VFS.delete(id);
                        } catch (error) {
                            alert(`Error deleting '${this.items.find(i => i.id === id)?.name || 'item'}' permanently: ${error.message}`);
                        }
                    }
                    this.selection.clear();
                    this.render();
                }
            });
        },
        restoreSelection() {
            if (!this.selection.size) return;
            this.app.Modal.confirm({
                title: 'Restore Items',
                message: `Are you sure you want to restore ${this.selection.size} item(s) from Trash? \nThey will be restored to '/Home' if their original parent is unknown.`,
                onConfirm: async () => {
                    // In a real VFS, you'd store original parent ID on deletion.
                    // For this example, we restore to /Home.
                    const restoreToPath = '/Home';
                    for (const id of this.selection) {
                        const itemNode = await this.app.VFS.getNode(id);
                        if (!itemNode) continue;

                        try {
                            // Check if an item with the same name already exists in /Home
                            const existingInHome = await this.app.VFS.getNodeByPath(`${restoreToPath}/${itemNode.name}`);
                            if (existingInHome) {
                                // If exists, try to rename it before restoring to avoid conflict
                                alert(`'${itemNode.name}' already exists in /Home. Please rename it manually before restoring.`);
                                continue; // Skip this item
                            } else {
                                await this.app.VFS.move(id, restoreToPath);
                            }
                        } catch (error) {
                            alert(`Error restoring '${itemNode.name}': ${error.message}`);
                        }
                    }
                    this.selection.clear();
                    this.render();
                }
            });
        },
        copySelection() {
            if(!this.selection.size) return;
            // Prevent copying if current path is trash
            if (this.currentPath === '/.trash') {
                alert("Cannot copy items from Trash.");
                return;
            }
            this.clipboard = { mode: 'copy', itemIds: [...this.selection] };
            this.updateStatusBar(); // Update status to show clipboard mode
        },
        cutSelection() {
            if(!this.selection.size) return;
            // Prevent cutting if current path is trash
            if (this.currentPath === '/.trash') {
                alert("Cannot cut items from Trash.");
                return;
            }
            this.clipboard = { mode: 'cut', itemIds: [...this.selection] };
            this.updateStatusBar(); // Update status to show clipboard mode
        },
        async pasteSelection() {
            if (!this.clipboard.itemIds.length) return;
            if (this.currentPath === '/.trash') {
                alert("Cannot paste items into Trash.");
                return;
            }

            const currentPath = this.currentPath;
            for(const id of this.clipboard.itemIds) {
                const itemNode = await this.app.VFS.getNode(id);
                if (!itemNode) continue;

                // Prevent pasting a folder into itself
                if (itemNode.type === 'folder' && (await this.app.VFS.constructPath(itemNode.id)).startsWith(currentPath) && itemNode.id !== (await this.app.VFS.getNodeByPath(currentPath)).id) {
                    alert(`Cannot paste folder '${itemNode.name}' into its own sub-path.`);
                    continue;
                }

                try {
                    if (this.clipboard.mode === 'copy') {
                        await this.app.VFS.copy(id, currentPath);
                    } else if (this.clipboard.mode === 'cut') {
                        await this.app.VFS.move(id, currentPath);
                    }
                } catch (error) {
                    alert(`Error pasting '${itemNode.name}': ${error.message}`);
                }
            }
            if (this.clipboard.mode === 'cut') {
                this.clipboard.itemIds = []; // Clear clipboard after cut-paste
                this.clipboard.mode = null;
            }
            this.render();
        },
        async uploadFiles(files) {
            if (this.currentPath === '/.trash') {
                alert("Cannot upload files into Trash.");
                return;
            }
            for (const file of files) {
                try {
                    await this.app.VFS.write(`${this.currentPath}/${file.name}`, file); // Pass file Blob directly
                } catch (error) {
                    alert(`Error uploading '${file.name}': ${error.message}`);
                }
            }
            this.render();
        },
        async downloadItem(id) {
            const node = await this.app.VFS.getNode(id);
            if(node && node.type === 'file') {
                try {
                    const blob = await this.app.VFS.read(id, 'blob'); // Read as Blob
                    const url = URL.createObjectURL(blob);
                    const a = this.app.dom.fileDownloader;
                    a.href = url;
                    a.download = node.name;
                    document.body.appendChild(a); // Append to body to ensure it's in DOM
                    a.click();
                    document.body.removeChild(a); // Clean up
                    URL.revokeObjectURL(url); // Release object URL
                } catch (error) {
                    alert(`Error preparing download for '${node.name}': ${error.message}`);
                }
            } else {
                alert('Cannot download a folder or non-existent item.');
            }
        },
        async openFileInViewer(node) {
            if (!node || node.type !== 'file') {
                alert('Invalid item selected for viewing.');
                return;
            }

            const ext = node.name.includes('.') ? node.name.split('.').pop().toLowerCase() : '';
            const textFileExtensions = ['txt', 'md', 'js', 'html', 'css', 'json', 'xml'];
            const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'];

            if (textFileExtensions.includes(ext) || (node.mimeType && node.mimeType.startsWith('text/'))) {
                try {
                    const fileContent = await this.app.VFS.read(node.id, 'string');
                    this.app.Modal.viewFile({
                        title: `Viewing / Editing: ${node.name}`,
                        contentHtml: `<textarea>${fileContent}</textarea>`,
                        onSave: async (newContent) => {
                            try {
                                // Write back with original MIME type if possible, otherwise text/plain
                                const newBlob = new Blob([newContent], { type: node.mimeType || 'text/plain' });
                                await this.app.VFS.write(await this.app.VFS.constructPath(node.id), newBlob);
                                this.render(); // Re-render to update file modification time/size
                                // alert('File saved successfully!'); // Optional feedback
                            } catch (error) {
                                alert(`Error saving file: ${error.message}`);
                            }
                        }
                    });
                } catch (error) {
                    alert(`Error loading text file for viewing: ${error.message}`);
                }
            } else if (imageExtensions.includes(ext) || (node.mimeType && node.mimeType.startsWith('image/'))) {
                try {
                    const imageUrl = await this.app.VFS.read(node.id, 'dataurl'); // Read as Data URL
                    if (imageUrl) {
                        this.app.Modal.viewFile({
                            title: `Viewing: ${node.name}`,
                            contentHtml: `<img src="${imageUrl}" alt="${node.name}" />`,
                            onClose: () => {
                                // Clean up the object URL when modal closes
                                if (imageUrl.startsWith('blob:')) URL.revokeObjectURL(imageUrl);
                            }
                        });
                    } else {
                         alert(`Could not generate image preview for '${node.name}'.`);
                    }
                } catch (error) {
                    alert(`Error loading image for viewing: ${error.message}`);
                }
            } else {
                // For other file types, offer download
                this.app.Modal.confirm({
                    title: 'No Viewer Available',
                    message: `No viewer available for '${node.name}' (type: ${ext || 'unknown'}). Do you want to download it instead?`,
                    onConfirm: () => {
                        this.downloadItem(node.id);
                    }
                });
            }
        },
        // New function to show properties modal
        async showProperties(nodeId) {
            const node = await this.app.VFS.getNode(nodeId);
            if (!node) {
                alert('Item not found.');
                return;
            }

            let sizeInfo = '';
            if (node.type === 'file') {
                sizeInfo = this.formatBytes(node.size);
            } else { // For folders, calculate total size (recursive, might be slow for large folders)
                try {
                    let totalSize = 0;
                    const calculateFolderSize = async (folderNode) => {
                        const children = await this.app.VFS.list(await this.app.VFS.constructPath(folderNode.id));
                        for (const child of children) {
                            if (child.type === 'file') {
                                totalSize += child.size;
                            } else {
                                await calculateFolderSize(child); // Recursively sum for subfolders
                            }
                        }
                    };
                    await calculateFolderSize(node);
                    sizeInfo = `${this.formatBytes(totalSize)} (${totalSize} bytes)`;
                } catch (e) {
                    console.error("Error calculating folder size:", e);
                    sizeInfo = "Error calculating size";
                }
            }


            const propertiesHtml = `
                <table>
                    <tr><td>Name:</td><td>${node.name || 'Root Folder'}</td></tr>
                    <tr><td>Type:</td><td>${node.type === 'folder' ? 'Folder' : 'File'}</td></tr>
                    <tr><td>Location:</td><td>${node.id === '/' ? '/' : (await this.app.VFS.constructPath(node.parentId) || 'Unknown')}</td></tr>
                    <tr><td>Size:</td><td>${sizeInfo}</td></tr>
                    <tr><td>Created:</td><td>${new Date(node.ctime).toLocaleString()}</td></tr>
                    <tr><td>Modified:</td><td>${new Date(node.mtime).toLocaleString()}</td></tr>
                    ${node.type === 'file' && node.mimeType ? `<tr><td>MIME Type:</td><td>${node.mimeType}</td></tr>` : ''}
                    <tr><td>ID:</td><td>${node.id}</td></tr>
                </table>
            `;

            this.app.Modal.showProperties({
                title: `Properties: ${node.name || 'Root Folder'}`,
                contentHtml: propertiesHtml,
                onClose: () => { /* optional callback */ }
            });
        },
        navigate(path) {
            // Normalize path: ensure it starts with / and no trailing slash unless it's root
            let cleanPath = path.startsWith('/') ? path : `/${path}`;
            if (cleanPath.length > 1 && cleanPath.endsWith('/')) {
                cleanPath = cleanPath.slice(0, -1);
            }

            // Prevent redundant navigation
            if (this.currentPath === cleanPath) return;

            // Ensure path exists and is a folder before navigating
            this.app.VFS.getNodeByPath(cleanPath).then(node => {
                if (!node) {
                    alert(`Path does not exist: '${cleanPath}'`);
                    return;
                }
                if (node.type !== 'folder') {
                    alert(`Cannot navigate to a file: '${cleanPath}'`);
                    return;
                }

                this.currentPath = cleanPath;
                // Manage history: truncate future entries if navigating backwards then forwards
                if(this.historyIndex < this.history.length-1) {
                    this.history.splice(this.historyIndex + 1);
                }
                this.history.push(this.currentPath);
                this.historyIndex = this.history.length - 1;
                this.selection.clear(); // Clear selection on navigation
                this.render();
            }).catch(error => {
                alert(`Navigation error: ${error.message}`);
                console.error(`Navigation error to ${cleanPath}:`, error);
            });
        },
        navigateHistory(dir) {
            const newIdx = this.historyIndex + dir;
            if(newIdx >= 0 && newIdx < this.history.length) {
                this.historyIndex = newIdx;
                this.currentPath = this.history[newIdx];
                this.selection.clear(); // Clear selection on history navigation
                this.render();
            }
        },
        updateNavButtons() {
            this.dom.toolbar.querySelector('.back-btn').disabled = this.historyIndex <= 0;
            this.dom.toolbar.querySelector('.fwd-btn').disabled = this.historyIndex >= this.history.length - 1;
            this.dom.toolbar.querySelector('.up-btn').disabled = this.currentPath === '/';
        },
        updateViewButtons() {
            this.dom.listViewBtn.classList.toggle('active', this.listView);
            this.dom.gridViewBtn.classList.toggle('active', !this.listView);
        },
        updateStatusBar() {
            let statusText = `${this.items.length} items`;
            if (this.selection.size > 0) {
                statusText += ` | ${this.selection.size} selected`;
            }
            if (this.clipboard.mode) {
                statusText += ` | Clipboard: ${this.clipboard.itemIds.length} item(s) to ${this.clipboard.mode}`;
            }
            this.dom.statusBar.textContent = statusText;
        },
        updateSelection() {
            this.dom.contentArea.querySelectorAll('.file-item').forEach(el => {
                el.classList.toggle('selected', this.selection.has(el.dataset.id));
            });
            this.updateStatusBar();
        },
        updateSidebarActiveItem() {
            this.dom.sidebar.querySelectorAll('.quick-access-item').forEach(el => {
                el.classList.toggle('active', el.dataset.path === this.currentPath);
            });
        },
        getIcon(item) {
            if (item.type === 'folder') {
                if (item.name === '.trash') return '🗑️'; // Specific icon for trash
                return '📁';
            }
            const ext = item.name.includes('.') ? item.name.split('.').pop().toLowerCase() : '';
            const mime = item.mimeType || ''; // Use stored MIME type if available

            // Priority: specific extension > MIME type > generic
            const icons = {
                // Images
                jpg:'🖼️', jpeg:'🖼️', png:'🖼️', gif:'🖼️', webp:'🖼️', bmp:'🖼️', svg:'🖼️',
                // Text/Code
                txt:'📄', md:'📝', js:'📜', html:'🌐', css:'🎨', json:'{}', xml:'<>', log:'📄', sh:'📜',
                // Archives
                zip:'📦', rar:'📦', tar:'📦', gz:'📦', '7z':'📦',
                // Audio
                mp3:'🎵', wav:'🎵', ogg:'🎵', flac:'🎵',
                // Video
                mp4:'🎬', webm:'🎬', ogv:'🎬', avi:'🎬', mov:'🎬',
                // Documents
                pdf:'📄', doc:'📝', docx:'📝', xls:'📊', xlsx:'📊', ppt:'📊', pptx:'📊', csv:'📊',
                // Executables (very generic, not for actual execution)
                exe:'⚙️', bat:'⚙️', sh:'⚙️',
            };

            if (icons[ext]) return icons[ext];

            // Fallback based on MIME type major category
            if (mime.startsWith('text/')) return '📄';
            if (mime.startsWith('image/')) return '🖼️';
            if (mime.startsWith('audio/')) return '🎵';
            if (mime.startsWith('video/')) return '🎬';
            if (mime.includes('zip') || mime.includes('archive')) return '📦';

            return '⚙️'; // Default gear icon for unknown types
        },
        formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const i = Math.floor(Math.log(bytes) / Math.log(1024));
            return `${parseFloat((bytes/Math.pow(1024,i)).toFixed(2))} ${['B','KB','MB','GB','TB'][i]}`;
        },
    };

    document.addEventListener('DOMContentLoaded', () => App.init());
    </script></body></html>
