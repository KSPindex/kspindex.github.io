<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index-Space Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Index-Space Theme Variables - Unified with Desktop */
        :root {
            --color-background: #0D1117;
            --color-text-primary: #E6EDF3;
            --color-text-secondary: #8B949E;
            --color-surface-1: #161B22; /* Primary background for main content */
            --color-surface-2: #0D1117; /* Darker background for panels */
            --color-border: #30363D;
            --color-accent: #58A6FF; /* Primary accent for highlights */
            --color-error: #DA3633;
            --color-warning: #D29922;

            --font-family: 'Inter', sans-serif;
            --font-mono: 'Fira Code', monospace;

            /* Terminal Specific Overrides */
            --term-bg: var(--color-background);
            --term-text-primary: var(--color-text-primary);
            --term-text-secondary: var(--color-text-secondary);
            --term-prompt-color: var(--color-accent);
            --term-error-color: var(--color-error);
            --term-warning-color: var(--color-warning);
            --term-input-bg: var(--color-surface-1);
            --term-border: var(--color-border);
        }
        body {
            font-family: var(--font-mono); /* Monospaced font for terminal */
            background-color: var(--term-bg);
            color: var(--term-text-primary);
            overflow: hidden;
            font-size: 14px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            user-select: text; /* Allow text selection in terminal */
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--term-bg); }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }

        #terminal-output {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9em;
            line-height: 1.4;
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
            word-break: break-all; /* Break long words */
        }
        #terminal-input-container {
            display: flex;
            align-items: center;
            padding: 10px;
            border-top: 1px solid var(--term-border);
            background-color: var(--term-input-bg);
            flex-shrink: 0;
        }
        #terminal-input {
            background: transparent;
            border: none;
            outline: none;
            width: 100%;
            color: var(--term-text-primary);
            font-family: var(--term-font-mono);
            font-size: 0.9em;
        }
        .output-line { padding: 2px 0; }
        .output-error { color: var(--term-error-color); }
        .output-warn { color: var(--term-warning-color); }
        .output-info { color: var(--term-text-secondary); }
        .prompt-text { color: var(--term-prompt-color); margin-right: 8px; }
    </style>
</head>
<body>
    <div id="terminal-output"></div>
    <div id="terminal-input-container">
        <span class="prompt-text">user@index-space $</span><input type="text" id="terminal-input" />
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <script src="https://unpkg.com/fengari-web/dist/fengari-web.js"></script>
    <script>
        const TerminalApp = {
            dom: {},
            state: {
                currentPath: '/', // Simulate current directory
                fileSystem: {}, // Simple mock for 'ls', 'cat'
                pyodide: null, pyodideReady: false, pyodideLoading: false,
                fengari: null, luaReady: false, luaLoading: false,
                terminalHistory: [],
                historyIndex: -1,
                currentInputBuffer: '', // Store current input while navigating history
            },

            init() {
                this.cacheDomElements();
                this.bindEvents();
                this.log('Welcome to Index-Space Terminal!', 'info');
                this.log('Type "help" for a list of commands.', 'info');
                this.log('Loading Python & Lua environments...', 'info');
                
                this.loadEnvironments();
                this.loadMockFileSystem(); // Load a simple mock file system
                
                // Announce to parent window (desktop.html) that terminal is ready
                if (window.parent) {
                    window.addEventListener('load', () => {
                        window.parent.postMessage({ type: 'appReady', payload: { appId: 'terminal', windowId: window.frameElement ? window.frameElement.id : null } }, '*');
                    });
                }
            },

            cacheDomElements() {
                this.dom.output = document.getElementById('terminal-output');
                this.dom.input = document.getElementById('terminal-input');
                this.dom.prompt = document.querySelector('.prompt-text');
            },

            bindEvents() {
                this.dom.input.addEventListener('keydown', this.handleInput.bind(this));
                // Listen for messages from other windows (e.g., desktop.html, if it sends direct commands)
                window.addEventListener('message', this.handleMessage.bind(this));
            },

            async loadEnvironments() {
                // Load Pyodide (Python)
                if (!this.state.pyodideLoading && !this.state.pyodideReady) {
                    this.state.pyodideLoading = true;
                    try {
                        this.state.pyodide = await loadPyodide();
                        this.state.pyodide.setStdout({ batched: (str) => this.log(str) });
                        this.state.pyodide.setStderr({ batched: (str) => this.log(str, 'error') });
                        this.state.pyodideReady = true;
                        this.log('Python environment ready.', 'info');
                    } catch (error) {
                        this.log(`Failed to load Python environment: ${error}`, 'error');
                    } finally {
                        this.state.pyodideLoading = false;
                    }
                }

                // Load Fengari (Lua)
                if (!this.state.luaLoading && !this.state.luaReady) {
                    this.state.luaLoading = true;
                    try {
                        this.state.fengari = window.fengari;
                        if (this.state.fengari) {
                            this.state.luaReady = true;
                            this.log('Lua environment ready.', 'info');
                        } else {
                             throw new Error("Fengari (Lua) library not found. Make sure it's loaded.");
                        }
                    } catch (error) {
                        this.log(`Failed to load Lua environment: ${error}`, 'error');
                    } finally {
                        this.state.luaLoading = false;
                    }
                }
            },

            loadMockFileSystem() {
                // A very simple mock file system for terminal commands
                this.state.fileSystem = {
                    '/': {
                        type: 'directory',
                        children: {
                            'home': { type: 'directory', children: {
                                'user': { type: 'directory', children: {
                                    'welcome.txt': { type: 'file', content: 'Hello from Index-Space Terminal! This is a mock file.\nTry "cat home/user/welcome.txt"'},
                                    'my_script.py': { type: 'file', content: 'print("This is a Python script in the terminal mock FS.")'}
                                }}
                            }},
                            'bin': { type: 'directory', children: {
                                'echo': { type: 'executable' },
                                'ls': { type: 'executable' },
                                'cat': { type: 'executable' },
                                'clear': { type: 'executable' },
                                'python': { type: 'executable' }, // For running Python files in mock FS
                                'lua': { type: 'executable' } // For running Lua files in mock FS
                            }}
                        }
                    }
                };
            },

            resolvePath(path) {
                let current = this.state.fileSystem['/'];
                let parts = path.split('/').filter(p => p);
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    if (!current.children || !current.children[part]) {
                        return null; // Path not found
                    }
                    current = current.children[part];
                }
                return current;
            },

            handleInput(e) {
                if (e.key === 'Enter') {
                    const cmdStr = e.target.value.trim();
                    if (cmdStr) {
                        this.exec(cmdStr);
                        // Add to history only if it's not a history navigation action
                        if (this.state.historyIndex === -1 || cmdStr !== this.state.terminalHistory[this.state.historyIndex]) {
                            this.state.terminalHistory.unshift(cmdStr);
                        }
                        this.state.historyIndex = -1; // Reset history index
                        this.state.currentInputBuffer = ''; // Clear buffer
                    }
                    e.target.value = '';
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault(); 
                    if (this.state.historyIndex === -1) {
                        this.state.currentInputBuffer = e.target.value; 
                    }
                    if (this.state.terminalHistory.length > 0 && this.state.historyIndex < this.state.terminalHistory.length - 1) {
                        this.state.historyIndex++;
                        e.target.value = this.state.terminalHistory[this.state.historyIndex];
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault(); 
                    if (this.state.historyIndex > 0) {
                        this.state.historyIndex--;
                        e.target.value = this.state.terminalHistory[this.state.historyIndex];
                    } else if (this.state.historyIndex === 0) {
                        this.state.historyIndex = -1;
                        e.target.value = this.state.currentInputBuffer; 
                    } else {
                        this.state.historyIndex = -1;
                        e.target.value = '';
                    }
                }
            },

            handleMessage(event) {
                // This terminal is mostly independent now, but can still receive messages.
                // For example, if desktop.html needs to send a global command.
                // editor.html will no longer send messages directly here; it uses its internal terminal.
                // So, this block is mostly for future extensions or debugging.
                const { type, payload } = event.data;
                switch (type) {
                    case 'globalTerminalCommand':
                        this.exec(payload.command);
                        break;
                    case 'clearTerminal': // Clear command from desktop/other source
                        this.clear();
                        break;
                    // Other messages from desktop.html could be handled here.
                }
            },

            log(msg, level = 'log') {
                const line = document.createElement('div');
                line.classList.add('output-line');
                if (level === 'error') line.classList.add('output-error');
                if (level === 'warn') line.classList.add('output-warn');
                if (level === 'info') line.classList.add('output-info');

                line.innerHTML = String(msg)
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;")
                    .replace(/\n/g, '<br>');

                this.dom.output.appendChild(line);
                this.dom.output.scrollTop = this.dom.output.scrollHeight;
            },

            clear() {
                this.dom.output.innerHTML = '';
                this.log('Index-Space Terminal.', 'info');
                this.log('Type "help" for a list of commands.', 'info');
            },

            async exec(cmdStr) {
                this.log(`${this.dom.prompt.textContent} ${cmdStr}`, 'prompt');
                const [cmd, ...args] = cmdStr.trim().split(/\s+/);

                switch(cmd) {
                    case 'clear':
                        this.clear();
                        break;
                    case 'help':
                        this.log('Available commands:');
                        this.log('- ls [path]: List directory contents');
                        this.log('- cd [path]: Change directory (mock)');
                        this.log('- pwd: Print working directory (mock)');
                        this.log('- cat [file]: Display file content');
                        this.log('- echo [message]: Display a message');
                        this.log('- python [file]: Run a Python script from mock FS');
                        this.log('- lua [file]: Run a Lua script from mock FS');
                        this.log('- clear: Clear the terminal screen');
                        this.log('- help: Show this help message');
                        break;
                    case 'echo':
                        this.log(args.join(' '));
                        break;
                    case 'ls':
                        const lsPath = args[0] || '.';
                        let targetDir;
                        if (lsPath === '.') {
                            targetDir = this.resolvePath(this.state.currentPath);
                        } else if (lsPath.startsWith('/')) {
                            targetDir = this.resolvePath(lsPath);
                        } else {
                            targetDir = this.resolvePath(`${this.state.currentPath === '/' ? '' : this.state.currentPath}/${lsPath}`);
                        }
                        
                        if (!targetDir || targetDir.type !== 'directory') {
                            this.log(`ls: cannot access '${lsPath}': No such file or directory`, 'error');
                            break;
                        }
                        
                        const items = Object.keys(targetDir.children || {}).sort();
                        if (items.length === 0) {
                            this.log(' (empty directory)');
                        } else {
                            items.forEach(item => {
                                const node = targetDir.children[item];
                                this.log(`${node.type === 'directory' ? 'drwxr-xr-x' : '-rw-r--r--'} ${item}${node.type === 'directory' ? '/' : ''}`);
                            });
                        }
                        break;
                    case 'cd':
                        const cdPath = args[0] || '/';
                        let newPath;
                        if (cdPath === '/') {
                            newPath = '/';
                        } else if (cdPath === '..') {
                            const parts = this.state.currentPath.split('/').filter(p => p);
                            if (parts.length > 0) {
                                parts.pop();
                            }
                            newPath = `/${parts.join('/')}`;
                            if (newPath === '') newPath = '/';
                        } else if (cdPath.startsWith('/')) {
                            newPath = cdPath;
                        } else {
                            newPath = `${this.state.currentPath === '/' ? '' : this.state.currentPath}/${cdPath}`;
                        }

                        const resolvedNewDir = this.resolvePath(newPath);
                        if (!resolvedNewDir || resolvedNewDir.type !== 'directory') {
                            this.log(`cd: ${cdPath}: No such directory`, 'error');
                        } else {
                            this.state.currentPath = newPath;
                            this.dom.prompt.textContent = `user@index-space ${this.state.currentPath} $`;
                        }
                        break;
                    case 'pwd':
                        this.log(this.state.currentPath);
                        break;
                    case 'cat':
                        const catFilePath = args[0];
                        if (!catFilePath) {
                            this.log('cat: missing operand', 'error');
                            break;
                        }
                        let fileToCat;
                        if (catFilePath.startsWith('/')) {
                            fileToCat = this.resolvePath(catFilePath);
                        } else {
                            fileToCat = this.resolvePath(`${this.state.currentPath === '/' ? '' : this.state.currentPath}/${catFilePath}`);
                        }

                        if (!fileToCat || fileToCat.type !== 'file') {
                            this.log(`cat: ${catFilePath}: No such file`, 'error');
                            break;
                        }
                        this.log(fileToCat.content);
                        break;
                    case 'python':
                    case 'lua':
                        const scriptPath = args[0];
                        if (!scriptPath) {
                            this.log(`${cmd}: missing script file`, 'error');
                            break;
                        }
                        let scriptFile;
                        if (scriptPath.startsWith('/')) {
                            scriptFile = this.resolvePath(scriptPath);
                        } else {
                            scriptFile = this.resolvePath(`${this.state.currentPath === '/' ? '' : this.state.currentPath}/${scriptPath}`);
                        }

                        if (!scriptFile || scriptFile.type !== 'file') {
                            this.log(`${cmd}: ${scriptPath}: No such file`, 'error');
                            break;
                        }
                        if (cmd === 'python' && !scriptFile.content.includes('python')) { // Basic check
                            this.log(`${scriptPath} does not seem to be a Python script.`, 'warn');
                        } else if (cmd === 'lua' && !scriptFile.content.includes('lua')) { // Basic check
                            this.log(`${scriptPath} does not seem to be a Lua script.`, 'warn');
                        }
                        
                        await this.runScriptContent(cmd, scriptFile.content, scriptPath);
                        break;
                    default:
                        this.log(`Command not found: ${cmd}. Type "help" for a list of commands.`, 'error');
                }
            },

            async runScriptContent(language, content, source = 'terminal') {
                this.log(`\n--- Running ${language} from ${source} ---`, 'info');
                try {
                    switch(language) {
                        case 'python':
                            if (this.state.pyodideReady) {
                                await this.state.pyodide.runPythonAsync(content);
                            } else {
                                this.log('Python environment not ready.', 'error');
                            }
                            break;
                        case 'lua':
                            if (this.state.luaReady) {
                                const fengari = this.state.fengari;
                                const L = fengari.lauxlib.luaL_newstate();
                                fengari.lualib.luaL_openlibs(L);

                                const capturedLuaOutput = [];
                                fengari.lua.lua_pushcfunction(L, () => {
                                    const nargs = fengari.lua.lua_gettop(L);
                                    let s = "";
                                    for (let i = 1; i <= nargs; i++) {
                                        s += fengari.lua.lua_tojsstring(L, i);
                                        if (i < nargs) s += "\t";
                                    }
                                    capturedLuaOutput.push(s);
                                    return 0;
                                });
                                fengari.lua.lua_setglobal(L, "print");

                                const status = fengari.lauxlib.luaL_dostring(L, fengari.to_luastring(content));
                                if (status !== 0) {
                                    this.log(fengari.lua.lua_tojsstring(L, -1), 'error');
                                }
                                if (capturedLuaOutput.length > 0) this.log(capturedLuaOutput.join('\n'));
                            } else {
                                this.log('Lua environment not ready.', 'error');
                            }
                            break;
                        default:
                            this.log(`No direct runtime in this terminal for ${language}.`, 'error');
                    }
                } catch (e) {
                    this.log(`Execution Error for ${language}: ${e.stack || e.message}`, 'error');
                    console.error(`Full error for ${language} execution:`, e);
                } finally {
                    this.log(`--- End of ${language} execution ---`, 'info');
                    this.dom.output.scrollTop = this.dom.output.scrollHeight;
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => TerminalApp.init());
    </script>
</body>
</html>
