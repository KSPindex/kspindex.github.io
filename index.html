<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index-Space: Entry Sequence</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* --- 제안서 Section 1.0 기반 스타일 --- */

        :root {
            --glow-color: hsl(210, 100%, 75%);
            --button-bg-start: #2a3a68;
            --button-bg-end: #1e294b;
            --glint-color: rgba(255, 255, 255, 0.2);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #020617;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            perspective: 800px;
            position: relative;
        }

        /* 1.1: 'Index-Space' Logotype */
        .logotype {
            font-size: clamp(2rem, 10vw, 6rem);
            font-weight: 900;
            display: flex;
            transform-style: preserve-3d;
            visibility: hidden; /* JS로 제어 */
        }

        .logotype.visible {
            visibility: visible;
        }

        .logotype span {
            display: inline-block;
            transform-style: preserve-3d;
            transition: transform 1s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
        }
        
        /* 제미나이 로고와 유사한 그라데이션 물결 효과 */
        .char-gradient {
            background: linear-gradient(120deg, #89f7fe, #66a6ff, #d3cce3, #e9e4f0, #ff89b5, #ff6b81);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradient-wave 8s ease infinite;
        }

        @keyframes gradient-wave {
            0%{background-position:0% 50%}
            50%{background-position:100% 50%}
            100%{background-position:0% 50%}
        }

        /* 3D 텍스트 애니메이션 Keyframes (수백개 정의의 축소판) */
        @keyframes rotate-in-left {
            from { transform: rotateY(90deg) translateZ(150px) translateX(-50px); opacity: 0; }
            to { transform: rotateY(0deg) translateZ(0) translateX(0); opacity: 1; }
        }
        
        @keyframes pop-out-deep {
            from { transform: translateZ(-300px) scale(0.5); opacity: 0; }
            to { transform: translateZ(0) scale(1); opacity: 1; }
        }
        
        @keyframes shatter-reassemble {
            0% { transform: translateY(40px) rotateX(-90deg) scale(1.2); opacity: 0; }
            50% { transform: translateY(-20px) rotateX(30deg) scale(0.9); opacity: 1; }
            100% { transform: translateY(0) rotateX(0deg) scale(1); opacity: 1; }
        }
        
        /* 1.2: Divider Transformation */
        .divider-container {
            height: 5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .divider {
            width: 15vw;
            max-width: 200px;
            height: 4px;
            background-color: #94a3b8;
            transition: transform 1.2s cubic-bezier(0.83, 0, 0.17, 1); /* 유기적 움직임을 위한 베지어 곡선 */
        }
        
        /* 1.2: Particle Explosion */
        .particle-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1px;
            height: 1px;
        }
        
        .particle {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            pointer-events: none;
        }

        /* 1.2: Erupted Text */
        .erupted-text-container {
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            font-weight: 700;
            color: #cbd5e1;
            display: flex;
            gap: 1rem;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .erupted-text-container .word {
            display: inline-block;
            opacity: 0;
        }
        
        /* 텍스트 물리 기반 애니메이션 (스프링 효과) */
        @keyframes spring-in {
            0% { transform: translateY(100%) scale(0.5); opacity: 0; }
            60% { transform: translateY(-15%) scale(1.1); opacity: 1; }
            80% { transform: translateY(5%) scale(0.95); }
            100% { transform: translateY(0%) scale(1); opacity: 1; }
        }

        /* 1.3: 'Start' Button Interaction */
        .start-button-container {
            margin-top: 3rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s, visibility 1s;
        }

        .start-button {
            padding: 1rem 2.5rem;
            font-size: 1.25rem;
            font-weight: 700;
            color: white;
            background: linear-gradient(145deg, var(--button-bg-end), var(--button-bg-start));
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 15px 5px rgba(100, 150, 255, 0), /* 초기 투명 글로우 */
                        0 4px 6px rgba(0,0,0,0.2),
                        inset 0 1px 1px rgba(255,255,255,0.1);
            transition: transform 0.2s ease, box-shadow 0.3s ease;
            animation: pulse-effect 3s infinite ease-in-out;
        }
        
        .start-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 25px 8px rgba(100, 150, 255, 0.4),
                        0 8px 15px rgba(0,0,0,0.3),
                        inset 0 1px 1px rgba(255,255,255,0.1);
        }

        .start-button:active {
            transform: translateY(0px);
        }
        
        /* 지속적인 맥박/글로우 효과 */
        @keyframes pulse-effect {
            0% { box-shadow: 0 0 15px 5px rgba(100, 150, 255, 0.1), 0 4px 6px rgba(0,0,0,0.2), inset 0 1px 1px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 0 25px 8px rgba(100, 150, 255, 0.3), 0 4px 6px rgba(0,0,0,0.2), inset 0 1px 1px rgba(255,255,255,0.1); }
            100% { box-shadow: 0 0 15px 5px rgba(100, 150, 255, 0.1), 0 4px 6px rgba(0,0,0,0.2), inset 0 1px 1px rgba(255,255,255,0.1); }
        }

        /* 마우스 호버 시 빛 반사 효과 */
        .start-button::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), var(--glint-color) 0%, transparent 40%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .start-button:hover::before {
            opacity: 1;
        }

        /* 클릭 시 물결 효과를 위한 캔버스 */
        #ripple-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.75rem;
            pointer-events: none;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Part 1.1: Logotype -->
        <h1 class="logotype" id="logotype">
            <!-- JS가 여기에 span 요소를 삽입합니다 -->
        </h1>

        <!-- Part 1.2: Divider and Erupted Text -->
        <div class="divider-container" id="dividerContainer">
            <div class="divider" id="divider"></div>
        </div>
        
        <div class="erupted-text-container" id="eruptedText">
            <!-- JS가 여기에 word span 요소를 삽입합니다 -->
        </div>

        <!-- Part 1.3: Start Button -->
        <div class="start-button-container" id="startButtonContainer">
            <button class="start-button" id="startButton">
                Start Now
                <canvas id="ripple-canvas"></canvas>
            </button>
        </div>

        <!-- 파티클을 담을 컨테이너 -->
        <div class="particle-container" id="particleContainer"></div>
    </div>

    <script>
    /**
     * Index-Space Entry Sequence Orchestrator
     * * 이 스크립트는 제안서 Section 1.0에 기술된 애니메이션 시퀀스를 제어합니다.
     * 각 모듈은 특정 애니메이션 책임을 가지며, 순차적으로 실행됩니다.
     * 이 모듈화된 접근 방식은 제안서의 '거대한 코드 라인 수 달성'과 
     * '극도로 세분화된 제어'라는 메타 목표에 부합합니다.
     */

    document.addEventListener('DOMContentLoaded', () => {
        /**
         * @module AnimationOrchestrator
         * @description 로고타이프의 3D 텍스트 애니메이션을 제어합니다.
         * 수만 라인에 달하는 "애니메이션 오케스트레이터" 모듈의 축소판입니다.
         * 각 글자에 동적으로 애니메이션 클래스와 딜레이를 할당합니다.
         */
        const AnimationOrchestrator = (() => {
            const logotypeEl = document.getElementById('logotype');
            const logoText = 'Index-Space';
            const animationPresets = ['rotate-in-left', 'pop-out-deep', 'shatter-reassemble'];

            function init() {
                // 1. 텍스트를 개별 <span>으로 분리
                logoText.split('').forEach(char => {
                    const charSpan = document.createElement('span');
                    if (char === ' ') {
                        charSpan.innerHTML = '&nbsp;';
                    } else {
                        charSpan.textContent = char;
                        charSpan.classList.add('char-gradient'); // 그라데이션 효과 적용
                    }
                    logotypeEl.appendChild(charSpan);
                });
            }

            function play() {
                logotypeEl.classList.add('visible');
                const charSpans = logotypeEl.querySelectorAll('span');
                const animationPromises = [];

                charSpans.forEach((span, index) => {
                    // 2. 각 글자에 애니메이션과 딜레이를 무작위로 할당
                    const randomAnimation = animationPresets[Math.floor(Math.random() * animationPresets.length)];
                    const animationDelay = index * 100; // 0.1초 간격으로 순차적 실행
                    
                    span.style.animation = `${randomAnimation} 1.2s cubic-bezier(0.165, 0.84, 0.44, 1) ${animationDelay}ms forwards`;
                    
                    // 마지막 애니메이션이 끝나는 시점을 알기 위해 Promise 사용
                    const promise = new Promise(resolve => {
                        setTimeout(resolve, animationDelay + 1200);
                    });
                    animationPromises.push(promise);
                });

                return Promise.all(animationPromises);
            }

            return { init, play };
        })();

        /**
         * @module DividerTransformer
         * @description 구분선 애니메이션과 파티클 폭발을 담당합니다.
         */
        const DividerTransformer = (() => {
            const containerEl = document.getElementById('dividerContainer');
            const dividerEl = document.getElementById('divider');

            function show() {
                containerEl.style.opacity = '1';
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            function transform() {
                dividerEl.style.transform = 'rotate(90deg)';
                return new Promise(resolve => setTimeout(resolve, 1200)); // transition 시간과 일치
            }
            
            function hide() {
                containerEl.style.opacity = '0';
                return new Promise(resolve => setTimeout(resolve, 500));
            }

            return { show, transform, hide };
        })();

        /**
         * @module ParticleEngine
         * @description requestAnimationFrame을 사용한 순수 JS 물리 기반 파티클 시뮬레이션.
         * 수백 개의 파티클을 생성하고 각 프레임마다 위치를 업데이트합니다.
         */
        const ParticleEngine = (() => {
            const containerEl = document.getElementById('particleContainer');
            let particles = [];
            const particleCount = 300;

            function createParticle() {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                const size = Math.random() * 4 + 1;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.background = `hsl(${Math.random() * 60 + 180}, 100%, ${Math.random() * 50 + 50}%)`;

                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 2;
                
                return {
                    el: particle,
                    x: 0,
                    y: 0,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    size: size
                };
            }
            
            function explode() {
                for (let i = 0; i < particleCount; i++) {
                    const p = createParticle();
                    particles.push(p);
                    containerEl.appendChild(p.el);
                }

                return new Promise(resolve => {
                    requestAnimationFrame(function animate() {
                        particles.forEach((p, index) => {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.vy += 0.05; // 중력 시뮬레이션
                            p.life -= 0.015;

                            if (p.life <= 0) {
                                p.el.remove();
                                particles.splice(index, 1);
                            } else {
                                p.el.style.transform = `translate(${p.x}px, ${p.y}px)`;
                                p.el.style.opacity = p.life;
                            }
                        });

                        if (particles.length > 0) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve(); // 모든 파티클이 사라지면 완료
                        }
                    });
                });
            }

            return { explode };
        })();

        /**
         * @module TextEruptor
         * @description 폭발 후 텍스트가 나타나는 애니메이션을 제어합니다.
         */
        const TextEruptor = (() => {
            const containerEl = document.getElementById('eruptedText');
            const text = "Index | The Best #1 Space | Space";
            const words = text.split(' | ');

            function init() {
                words.forEach(wordStr => {
                    const wordSpan = document.createElement('span');
                    wordSpan.classList.add('word');
                    wordSpan.textContent = wordStr;
                    containerEl.appendChild(wordSpan);
                });
            }

            function play() {
                containerEl.style.opacity = '1';
                const wordSpans = containerEl.querySelectorAll('.word');
                const promises = [];
                
                wordSpans.forEach((span, index) => {
                    const delay = index * 200;
                    span.style.animation = `spring-in 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) ${delay}ms forwards`;
                    promises.push(new Promise(resolve => setTimeout(resolve, delay + 800)));
                });
                
                return Promise.all(promises);
            }

            return { init, play };
        })();

        /**
         * @module StartButtonInteractor
         * @description 'Start Now' 버튼의 등장 및 상호작용 효과를 담당합니다.
         */
        const StartButtonInteractor = (() => {
            const containerEl = document.getElementById('startButtonContainer');
            const buttonEl = document.getElementById('startButton');
            const canvasEl = document.getElementById('ripple-canvas');
            const ctx = canvasEl.getContext('2d');
            let ripples = [];

            function resizeCanvas() {
                const rect = buttonEl.getBoundingClientRect();
                canvasEl.width = rect.width;
                canvasEl.height = rect.height;
            }

            function init() {
                // Glint effect
                buttonEl.addEventListener('mousemove', e => {
                    const rect = buttonEl.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    buttonEl.style.setProperty('--mouse-x', `${x}px`);
                    buttonEl.style.setProperty('--mouse-y', `${y}px`);
                });

                // Ripple effect
                buttonEl.addEventListener('click', e => {
                    const rect = buttonEl.getBoundingClientRect();
                    ripples.push({
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top,
                        radius: 0,
                        alpha: 1
                    });
                    if (ripples.length === 1) requestAnimationFrame(drawRipples);
                });
                
                window.addEventListener('resize', resizeCanvas);
            }

            function drawRipples() {
                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);
                ripples.forEach((ripple, index) => {
                    ripple.radius += 2;
                    ripple.alpha -= 0.02;
                    
                    if (ripple.alpha <= 0) {
                        ripples.splice(index, 1);
                    } else {
                        ctx.beginPath();
                        ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${ripple.alpha * 0.3})`;
                        ctx.fill();
                    }
                });

                if (ripples.length > 0) {
                    requestAnimationFrame(drawRipples);
                }
            }

            function show() {
                containerEl.style.visibility = 'visible';
                containerEl.style.opacity = '1';
                resizeCanvas();
                return new Promise(resolve => setTimeout(resolve, 1000));
            }

            return { init, show };
        })();
        
        /**
         * @function main
         * @description 전체 애니메이션 시퀀스를 순차적으로 실행하는 메인 함수.
         */
        async function main() {
            // 초기화
            AnimationOrchestrator.init();
            TextEruptor.init();
            StartButtonInteractor.init();

            // 1. 로고 애니메이션 시작 및 완료 대기
            await AnimationOrchestrator.play();
            await new Promise(res => setTimeout(res, 500)); // 약간의 쉼

            // 2. 구분선 등장 및 변형
            await DividerTransformer.show();
            await DividerTransformer.transform();

            // 3. 파티클 폭발 및 구분선 사라짐
            const particlePromise = ParticleEngine.explode();
            await DividerTransformer.hide();
            await particlePromise; // 모든 파티클이 사라질 때까지 대기

            // 4. 텍스트 분출
            await TextEruptor.play();
            await new Promise(res => setTimeout(res, 300));

            // 5. 'Start Now' 버튼 등장
            await StartButtonInteractor.show();
        }

        // 시퀀스 시작
        main();
    });
    </script>
</body>
</html>
